// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RPG.proto

#ifndef PROTOBUF_RPG_2eproto__INCLUDED
#define PROTOBUF_RPG_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace RPG {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RPG_2eproto();
void protobuf_AssignDesc_RPG_2eproto();
void protobuf_ShutdownFile_RPG_2eproto();

class player;
class npc;
class use_item;
class monster;
class equips;
class dungeon_setup;
class locations;
class story;

// ===================================================================

class player : public ::google::protobuf::Message {
 public:
  player();
  virtual ~player();

  player(const player& from);

  inline player& operator=(const player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const player& default_instance();

  void Swap(player* other);

  // implements Message ----------------------------------------------

  player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const player& from);
  void MergeFrom(const player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 money = 1;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 1;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // required string race_class = 2;
  inline bool has_race_class() const;
  inline void clear_race_class();
  static const int kRaceClassFieldNumber = 2;
  inline const ::std::string& race_class() const;
  inline void set_race_class(const ::std::string& value);
  inline void set_race_class(const char* value);
  inline void set_race_class(const char* value, size_t size);
  inline ::std::string* mutable_race_class();
  inline ::std::string* release_race_class();
  inline void set_allocated_race_class(::std::string* race_class);

  // required int32 health = 3;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 3;
  inline ::google::protobuf::int32 health() const;
  inline void set_health(::google::protobuf::int32 value);

  // required int32 max_health = 4;
  inline bool has_max_health() const;
  inline void clear_max_health();
  static const int kMaxHealthFieldNumber = 4;
  inline ::google::protobuf::int32 max_health() const;
  inline void set_max_health(::google::protobuf::int32 value);

  // required int32 exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // required int32 level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 dmg = 7;
  inline bool has_dmg() const;
  inline void clear_dmg();
  static const int kDmgFieldNumber = 7;
  inline ::google::protobuf::int32 dmg() const;
  inline void set_dmg(::google::protobuf::int32 value);

  // required string player_class = 8;
  inline bool has_player_class() const;
  inline void clear_player_class();
  static const int kPlayerClassFieldNumber = 8;
  inline const ::std::string& player_class() const;
  inline void set_player_class(const ::std::string& value);
  inline void set_player_class(const char* value);
  inline void set_player_class(const char* value, size_t size);
  inline ::std::string* mutable_player_class();
  inline ::std::string* release_player_class();
  inline void set_allocated_player_class(::std::string* player_class);

  // repeated string inventory = 9;
  inline int inventory_size() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 9;
  inline const ::std::string& inventory(int index) const;
  inline ::std::string* mutable_inventory(int index);
  inline void set_inventory(int index, const ::std::string& value);
  inline void set_inventory(int index, const char* value);
  inline void set_inventory(int index, const char* value, size_t size);
  inline ::std::string* add_inventory();
  inline void add_inventory(const ::std::string& value);
  inline void add_inventory(const char* value);
  inline void add_inventory(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& inventory() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_inventory();

  // repeated string equip_places_key = 10;
  inline int equip_places_key_size() const;
  inline void clear_equip_places_key();
  static const int kEquipPlacesKeyFieldNumber = 10;
  inline const ::std::string& equip_places_key(int index) const;
  inline ::std::string* mutable_equip_places_key(int index);
  inline void set_equip_places_key(int index, const ::std::string& value);
  inline void set_equip_places_key(int index, const char* value);
  inline void set_equip_places_key(int index, const char* value, size_t size);
  inline ::std::string* add_equip_places_key();
  inline void add_equip_places_key(const ::std::string& value);
  inline void add_equip_places_key(const char* value);
  inline void add_equip_places_key(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& equip_places_key() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_equip_places_key();

  // repeated string equip_places_value = 11;
  inline int equip_places_value_size() const;
  inline void clear_equip_places_value();
  static const int kEquipPlacesValueFieldNumber = 11;
  inline const ::std::string& equip_places_value(int index) const;
  inline ::std::string* mutable_equip_places_value(int index);
  inline void set_equip_places_value(int index, const ::std::string& value);
  inline void set_equip_places_value(int index, const char* value);
  inline void set_equip_places_value(int index, const char* value, size_t size);
  inline ::std::string* add_equip_places_value();
  inline void add_equip_places_value(const ::std::string& value);
  inline void add_equip_places_value(const char* value);
  inline void add_equip_places_value(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& equip_places_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_equip_places_value();

  // @@protoc_insertion_point(class_scope:RPG.player)
 private:
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_race_class();
  inline void clear_has_race_class();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_max_health();
  inline void clear_has_max_health();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_dmg();
  inline void clear_has_dmg();
  inline void set_has_player_class();
  inline void clear_has_player_class();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* race_class_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 health_;
  ::google::protobuf::int32 max_health_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 dmg_;
  ::std::string* player_class_;
  ::google::protobuf::RepeatedPtrField< ::std::string> inventory_;
  ::google::protobuf::RepeatedPtrField< ::std::string> equip_places_key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> equip_places_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_RPG_2eproto();
  friend void protobuf_AssignDesc_RPG_2eproto();
  friend void protobuf_ShutdownFile_RPG_2eproto();

  void InitAsDefaultInstance();
  static player* default_instance_;
};
// -------------------------------------------------------------------

class npc : public ::google::protobuf::Message {
 public:
  npc();
  virtual ~npc();

  npc(const npc& from);

  inline npc& operator=(const npc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const npc& default_instance();

  void Swap(npc* other);

  // implements Message ----------------------------------------------

  npc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const npc& from);
  void MergeFrom(const npc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string smith_items_to_buy_key = 12;
  inline int smith_items_to_buy_key_size() const;
  inline void clear_smith_items_to_buy_key();
  static const int kSmithItemsToBuyKeyFieldNumber = 12;
  inline const ::std::string& smith_items_to_buy_key(int index) const;
  inline ::std::string* mutable_smith_items_to_buy_key(int index);
  inline void set_smith_items_to_buy_key(int index, const ::std::string& value);
  inline void set_smith_items_to_buy_key(int index, const char* value);
  inline void set_smith_items_to_buy_key(int index, const char* value, size_t size);
  inline ::std::string* add_smith_items_to_buy_key();
  inline void add_smith_items_to_buy_key(const ::std::string& value);
  inline void add_smith_items_to_buy_key(const char* value);
  inline void add_smith_items_to_buy_key(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& smith_items_to_buy_key() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_smith_items_to_buy_key();

  // repeated int32 smith_items_to_buy_value = 13;
  inline int smith_items_to_buy_value_size() const;
  inline void clear_smith_items_to_buy_value();
  static const int kSmithItemsToBuyValueFieldNumber = 13;
  inline ::google::protobuf::int32 smith_items_to_buy_value(int index) const;
  inline void set_smith_items_to_buy_value(int index, ::google::protobuf::int32 value);
  inline void add_smith_items_to_buy_value(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      smith_items_to_buy_value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_smith_items_to_buy_value();

  // repeated string smith_items_to_sell_key = 14;
  inline int smith_items_to_sell_key_size() const;
  inline void clear_smith_items_to_sell_key();
  static const int kSmithItemsToSellKeyFieldNumber = 14;
  inline const ::std::string& smith_items_to_sell_key(int index) const;
  inline ::std::string* mutable_smith_items_to_sell_key(int index);
  inline void set_smith_items_to_sell_key(int index, const ::std::string& value);
  inline void set_smith_items_to_sell_key(int index, const char* value);
  inline void set_smith_items_to_sell_key(int index, const char* value, size_t size);
  inline ::std::string* add_smith_items_to_sell_key();
  inline void add_smith_items_to_sell_key(const ::std::string& value);
  inline void add_smith_items_to_sell_key(const char* value);
  inline void add_smith_items_to_sell_key(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& smith_items_to_sell_key() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_smith_items_to_sell_key();

  // repeated int32 smith_items_to_sell_value = 15;
  inline int smith_items_to_sell_value_size() const;
  inline void clear_smith_items_to_sell_value();
  static const int kSmithItemsToSellValueFieldNumber = 15;
  inline ::google::protobuf::int32 smith_items_to_sell_value(int index) const;
  inline void set_smith_items_to_sell_value(int index, ::google::protobuf::int32 value);
  inline void add_smith_items_to_sell_value(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      smith_items_to_sell_value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_smith_items_to_sell_value();

  // @@protoc_insertion_point(class_scope:RPG.npc)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> smith_items_to_buy_key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > smith_items_to_buy_value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> smith_items_to_sell_key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > smith_items_to_sell_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_RPG_2eproto();
  friend void protobuf_AssignDesc_RPG_2eproto();
  friend void protobuf_ShutdownFile_RPG_2eproto();

  void InitAsDefaultInstance();
  static npc* default_instance_;
};
// -------------------------------------------------------------------

class use_item : public ::google::protobuf::Message {
 public:
  use_item();
  virtual ~use_item();

  use_item(const use_item& from);

  inline use_item& operator=(const use_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const use_item& default_instance();

  void Swap(use_item* other);

  // implements Message ----------------------------------------------

  use_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const use_item& from);
  void MergeFrom(const use_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string picked_potion = 16;
  inline bool has_picked_potion() const;
  inline void clear_picked_potion();
  static const int kPickedPotionFieldNumber = 16;
  inline const ::std::string& picked_potion() const;
  inline void set_picked_potion(const ::std::string& value);
  inline void set_picked_potion(const char* value);
  inline void set_picked_potion(const char* value, size_t size);
  inline ::std::string* mutable_picked_potion();
  inline ::std::string* release_picked_potion();
  inline void set_allocated_picked_potion(::std::string* picked_potion);

  // optional int32 wear_off = 17;
  inline bool has_wear_off() const;
  inline void clear_wear_off();
  static const int kWearOffFieldNumber = 17;
  inline ::google::protobuf::int32 wear_off() const;
  inline void set_wear_off(::google::protobuf::int32 value);

  // repeated string health_restores = 18;
  inline int health_restores_size() const;
  inline void clear_health_restores();
  static const int kHealthRestoresFieldNumber = 18;
  inline const ::std::string& health_restores(int index) const;
  inline ::std::string* mutable_health_restores(int index);
  inline void set_health_restores(int index, const ::std::string& value);
  inline void set_health_restores(int index, const char* value);
  inline void set_health_restores(int index, const char* value, size_t size);
  inline ::std::string* add_health_restores();
  inline void add_health_restores(const ::std::string& value);
  inline void add_health_restores(const char* value);
  inline void add_health_restores(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& health_restores() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_health_restores();

  // repeated string poisons = 19;
  inline int poisons_size() const;
  inline void clear_poisons();
  static const int kPoisonsFieldNumber = 19;
  inline const ::std::string& poisons(int index) const;
  inline ::std::string* mutable_poisons(int index);
  inline void set_poisons(int index, const ::std::string& value);
  inline void set_poisons(int index, const char* value);
  inline void set_poisons(int index, const char* value, size_t size);
  inline ::std::string* add_poisons();
  inline void add_poisons(const ::std::string& value);
  inline void add_poisons(const char* value);
  inline void add_poisons(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& poisons() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_poisons();

  // repeated string temp_boosts = 20;
  inline int temp_boosts_size() const;
  inline void clear_temp_boosts();
  static const int kTempBoostsFieldNumber = 20;
  inline const ::std::string& temp_boosts(int index) const;
  inline ::std::string* mutable_temp_boosts(int index);
  inline void set_temp_boosts(int index, const ::std::string& value);
  inline void set_temp_boosts(int index, const char* value);
  inline void set_temp_boosts(int index, const char* value, size_t size);
  inline ::std::string* add_temp_boosts();
  inline void add_temp_boosts(const ::std::string& value);
  inline void add_temp_boosts(const char* value);
  inline void add_temp_boosts(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& temp_boosts() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_temp_boosts();

  // repeated string perm_boosts = 21;
  inline int perm_boosts_size() const;
  inline void clear_perm_boosts();
  static const int kPermBoostsFieldNumber = 21;
  inline const ::std::string& perm_boosts(int index) const;
  inline ::std::string* mutable_perm_boosts(int index);
  inline void set_perm_boosts(int index, const ::std::string& value);
  inline void set_perm_boosts(int index, const char* value);
  inline void set_perm_boosts(int index, const char* value, size_t size);
  inline ::std::string* add_perm_boosts();
  inline void add_perm_boosts(const ::std::string& value);
  inline void add_perm_boosts(const char* value);
  inline void add_perm_boosts(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& perm_boosts() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_perm_boosts();

  // repeated string misc = 22;
  inline int misc_size() const;
  inline void clear_misc();
  static const int kMiscFieldNumber = 22;
  inline const ::std::string& misc(int index) const;
  inline ::std::string* mutable_misc(int index);
  inline void set_misc(int index, const ::std::string& value);
  inline void set_misc(int index, const char* value);
  inline void set_misc(int index, const char* value, size_t size);
  inline ::std::string* add_misc();
  inline void add_misc(const ::std::string& value);
  inline void add_misc(const char* value);
  inline void add_misc(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& misc() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_misc();

  // @@protoc_insertion_point(class_scope:RPG.use_item)
 private:
  inline void set_has_picked_potion();
  inline void clear_has_picked_potion();
  inline void set_has_wear_off();
  inline void clear_has_wear_off();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* picked_potion_;
  ::google::protobuf::RepeatedPtrField< ::std::string> health_restores_;
  ::google::protobuf::RepeatedPtrField< ::std::string> poisons_;
  ::google::protobuf::RepeatedPtrField< ::std::string> temp_boosts_;
  ::google::protobuf::RepeatedPtrField< ::std::string> perm_boosts_;
  ::google::protobuf::RepeatedPtrField< ::std::string> misc_;
  ::google::protobuf::int32 wear_off_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_RPG_2eproto();
  friend void protobuf_AssignDesc_RPG_2eproto();
  friend void protobuf_ShutdownFile_RPG_2eproto();

  void InitAsDefaultInstance();
  static use_item* default_instance_;
};
// -------------------------------------------------------------------

class monster : public ::google::protobuf::Message {
 public:
  monster();
  virtual ~monster();

  monster(const monster& from);

  inline monster& operator=(const monster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const monster& default_instance();

  void Swap(monster* other);

  // implements Message ----------------------------------------------

  monster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const monster& from);
  void MergeFrom(const monster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string mon_count = 23;
  inline int mon_count_size() const;
  inline void clear_mon_count();
  static const int kMonCountFieldNumber = 23;
  inline const ::std::string& mon_count(int index) const;
  inline ::std::string* mutable_mon_count(int index);
  inline void set_mon_count(int index, const ::std::string& value);
  inline void set_mon_count(int index, const char* value);
  inline void set_mon_count(int index, const char* value, size_t size);
  inline ::std::string* add_mon_count();
  inline void add_mon_count(const ::std::string& value);
  inline void add_mon_count(const char* value);
  inline void add_mon_count(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mon_count() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mon_count();

  // required int32 mon_level = 24;
  inline bool has_mon_level() const;
  inline void clear_mon_level();
  static const int kMonLevelFieldNumber = 24;
  inline ::google::protobuf::int32 mon_level() const;
  inline void set_mon_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RPG.monster)
 private:
  inline void set_has_mon_level();
  inline void clear_has_mon_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> mon_count_;
  ::google::protobuf::int32 mon_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RPG_2eproto();
  friend void protobuf_AssignDesc_RPG_2eproto();
  friend void protobuf_ShutdownFile_RPG_2eproto();

  void InitAsDefaultInstance();
  static monster* default_instance_;
};
// -------------------------------------------------------------------

class equips : public ::google::protobuf::Message {
 public:
  equips();
  virtual ~equips();

  equips(const equips& from);

  inline equips& operator=(const equips& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const equips& default_instance();

  void Swap(equips* other);

  // implements Message ----------------------------------------------

  equips* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const equips& from);
  void MergeFrom(const equips& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string h_head = 25;
  inline int h_head_size() const;
  inline void clear_h_head();
  static const int kHHeadFieldNumber = 25;
  inline const ::std::string& h_head(int index) const;
  inline ::std::string* mutable_h_head(int index);
  inline void set_h_head(int index, const ::std::string& value);
  inline void set_h_head(int index, const char* value);
  inline void set_h_head(int index, const char* value, size_t size);
  inline ::std::string* add_h_head();
  inline void add_h_head(const ::std::string& value);
  inline void add_h_head(const char* value);
  inline void add_h_head(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& h_head() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_h_head();

  // repeated string h_chest = 26;
  inline int h_chest_size() const;
  inline void clear_h_chest();
  static const int kHChestFieldNumber = 26;
  inline const ::std::string& h_chest(int index) const;
  inline ::std::string* mutable_h_chest(int index);
  inline void set_h_chest(int index, const ::std::string& value);
  inline void set_h_chest(int index, const char* value);
  inline void set_h_chest(int index, const char* value, size_t size);
  inline ::std::string* add_h_chest();
  inline void add_h_chest(const ::std::string& value);
  inline void add_h_chest(const char* value);
  inline void add_h_chest(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& h_chest() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_h_chest();

  // repeated string h_arm = 27;
  inline int h_arm_size() const;
  inline void clear_h_arm();
  static const int kHArmFieldNumber = 27;
  inline const ::std::string& h_arm(int index) const;
  inline ::std::string* mutable_h_arm(int index);
  inline void set_h_arm(int index, const ::std::string& value);
  inline void set_h_arm(int index, const char* value);
  inline void set_h_arm(int index, const char* value, size_t size);
  inline ::std::string* add_h_arm();
  inline void add_h_arm(const ::std::string& value);
  inline void add_h_arm(const char* value);
  inline void add_h_arm(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& h_arm() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_h_arm();

  // repeated string h_hand = 28;
  inline int h_hand_size() const;
  inline void clear_h_hand();
  static const int kHHandFieldNumber = 28;
  inline const ::std::string& h_hand(int index) const;
  inline ::std::string* mutable_h_hand(int index);
  inline void set_h_hand(int index, const ::std::string& value);
  inline void set_h_hand(int index, const char* value);
  inline void set_h_hand(int index, const char* value, size_t size);
  inline ::std::string* add_h_hand();
  inline void add_h_hand(const ::std::string& value);
  inline void add_h_hand(const char* value);
  inline void add_h_hand(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& h_hand() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_h_hand();

  // repeated string h_leg = 29;
  inline int h_leg_size() const;
  inline void clear_h_leg();
  static const int kHLegFieldNumber = 29;
  inline const ::std::string& h_leg(int index) const;
  inline ::std::string* mutable_h_leg(int index);
  inline void set_h_leg(int index, const ::std::string& value);
  inline void set_h_leg(int index, const char* value);
  inline void set_h_leg(int index, const char* value, size_t size);
  inline ::std::string* add_h_leg();
  inline void add_h_leg(const ::std::string& value);
  inline void add_h_leg(const char* value);
  inline void add_h_leg(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& h_leg() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_h_leg();

  // repeated string h_feet = 30;
  inline int h_feet_size() const;
  inline void clear_h_feet();
  static const int kHFeetFieldNumber = 30;
  inline const ::std::string& h_feet(int index) const;
  inline ::std::string* mutable_h_feet(int index);
  inline void set_h_feet(int index, const ::std::string& value);
  inline void set_h_feet(int index, const char* value);
  inline void set_h_feet(int index, const char* value, size_t size);
  inline ::std::string* add_h_feet();
  inline void add_h_feet(const ::std::string& value);
  inline void add_h_feet(const char* value);
  inline void add_h_feet(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& h_feet() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_h_feet();

  // repeated string l_head = 31;
  inline int l_head_size() const;
  inline void clear_l_head();
  static const int kLHeadFieldNumber = 31;
  inline const ::std::string& l_head(int index) const;
  inline ::std::string* mutable_l_head(int index);
  inline void set_l_head(int index, const ::std::string& value);
  inline void set_l_head(int index, const char* value);
  inline void set_l_head(int index, const char* value, size_t size);
  inline ::std::string* add_l_head();
  inline void add_l_head(const ::std::string& value);
  inline void add_l_head(const char* value);
  inline void add_l_head(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& l_head() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_l_head();

  // repeated string l_chest = 32;
  inline int l_chest_size() const;
  inline void clear_l_chest();
  static const int kLChestFieldNumber = 32;
  inline const ::std::string& l_chest(int index) const;
  inline ::std::string* mutable_l_chest(int index);
  inline void set_l_chest(int index, const ::std::string& value);
  inline void set_l_chest(int index, const char* value);
  inline void set_l_chest(int index, const char* value, size_t size);
  inline ::std::string* add_l_chest();
  inline void add_l_chest(const ::std::string& value);
  inline void add_l_chest(const char* value);
  inline void add_l_chest(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& l_chest() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_l_chest();

  // repeated string l_arm = 33;
  inline int l_arm_size() const;
  inline void clear_l_arm();
  static const int kLArmFieldNumber = 33;
  inline const ::std::string& l_arm(int index) const;
  inline ::std::string* mutable_l_arm(int index);
  inline void set_l_arm(int index, const ::std::string& value);
  inline void set_l_arm(int index, const char* value);
  inline void set_l_arm(int index, const char* value, size_t size);
  inline ::std::string* add_l_arm();
  inline void add_l_arm(const ::std::string& value);
  inline void add_l_arm(const char* value);
  inline void add_l_arm(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& l_arm() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_l_arm();

  // repeated string l_hand = 34;
  inline int l_hand_size() const;
  inline void clear_l_hand();
  static const int kLHandFieldNumber = 34;
  inline const ::std::string& l_hand(int index) const;
  inline ::std::string* mutable_l_hand(int index);
  inline void set_l_hand(int index, const ::std::string& value);
  inline void set_l_hand(int index, const char* value);
  inline void set_l_hand(int index, const char* value, size_t size);
  inline ::std::string* add_l_hand();
  inline void add_l_hand(const ::std::string& value);
  inline void add_l_hand(const char* value);
  inline void add_l_hand(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& l_hand() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_l_hand();

  // repeated string l_leg = 35;
  inline int l_leg_size() const;
  inline void clear_l_leg();
  static const int kLLegFieldNumber = 35;
  inline const ::std::string& l_leg(int index) const;
  inline ::std::string* mutable_l_leg(int index);
  inline void set_l_leg(int index, const ::std::string& value);
  inline void set_l_leg(int index, const char* value);
  inline void set_l_leg(int index, const char* value, size_t size);
  inline ::std::string* add_l_leg();
  inline void add_l_leg(const ::std::string& value);
  inline void add_l_leg(const char* value);
  inline void add_l_leg(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& l_leg() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_l_leg();

  // repeated string l_feet = 36;
  inline int l_feet_size() const;
  inline void clear_l_feet();
  static const int kLFeetFieldNumber = 36;
  inline const ::std::string& l_feet(int index) const;
  inline ::std::string* mutable_l_feet(int index);
  inline void set_l_feet(int index, const ::std::string& value);
  inline void set_l_feet(int index, const char* value);
  inline void set_l_feet(int index, const char* value, size_t size);
  inline ::std::string* add_l_feet();
  inline void add_l_feet(const ::std::string& value);
  inline void add_l_feet(const char* value);
  inline void add_l_feet(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& l_feet() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_l_feet();

  // repeated string a_head = 37;
  inline int a_head_size() const;
  inline void clear_a_head();
  static const int kAHeadFieldNumber = 37;
  inline const ::std::string& a_head(int index) const;
  inline ::std::string* mutable_a_head(int index);
  inline void set_a_head(int index, const ::std::string& value);
  inline void set_a_head(int index, const char* value);
  inline void set_a_head(int index, const char* value, size_t size);
  inline ::std::string* add_a_head();
  inline void add_a_head(const ::std::string& value);
  inline void add_a_head(const char* value);
  inline void add_a_head(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& a_head() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_a_head();

  // repeated string a_chest = 38;
  inline int a_chest_size() const;
  inline void clear_a_chest();
  static const int kAChestFieldNumber = 38;
  inline const ::std::string& a_chest(int index) const;
  inline ::std::string* mutable_a_chest(int index);
  inline void set_a_chest(int index, const ::std::string& value);
  inline void set_a_chest(int index, const char* value);
  inline void set_a_chest(int index, const char* value, size_t size);
  inline ::std::string* add_a_chest();
  inline void add_a_chest(const ::std::string& value);
  inline void add_a_chest(const char* value);
  inline void add_a_chest(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& a_chest() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_a_chest();

  // repeated string a_arm = 39;
  inline int a_arm_size() const;
  inline void clear_a_arm();
  static const int kAArmFieldNumber = 39;
  inline const ::std::string& a_arm(int index) const;
  inline ::std::string* mutable_a_arm(int index);
  inline void set_a_arm(int index, const ::std::string& value);
  inline void set_a_arm(int index, const char* value);
  inline void set_a_arm(int index, const char* value, size_t size);
  inline ::std::string* add_a_arm();
  inline void add_a_arm(const ::std::string& value);
  inline void add_a_arm(const char* value);
  inline void add_a_arm(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& a_arm() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_a_arm();

  // repeated string a_hand = 40;
  inline int a_hand_size() const;
  inline void clear_a_hand();
  static const int kAHandFieldNumber = 40;
  inline const ::std::string& a_hand(int index) const;
  inline ::std::string* mutable_a_hand(int index);
  inline void set_a_hand(int index, const ::std::string& value);
  inline void set_a_hand(int index, const char* value);
  inline void set_a_hand(int index, const char* value, size_t size);
  inline ::std::string* add_a_hand();
  inline void add_a_hand(const ::std::string& value);
  inline void add_a_hand(const char* value);
  inline void add_a_hand(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& a_hand() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_a_hand();

  // repeated string a_leg = 41;
  inline int a_leg_size() const;
  inline void clear_a_leg();
  static const int kALegFieldNumber = 41;
  inline const ::std::string& a_leg(int index) const;
  inline ::std::string* mutable_a_leg(int index);
  inline void set_a_leg(int index, const ::std::string& value);
  inline void set_a_leg(int index, const char* value);
  inline void set_a_leg(int index, const char* value, size_t size);
  inline ::std::string* add_a_leg();
  inline void add_a_leg(const ::std::string& value);
  inline void add_a_leg(const char* value);
  inline void add_a_leg(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& a_leg() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_a_leg();

  // repeated string a_feet = 42;
  inline int a_feet_size() const;
  inline void clear_a_feet();
  static const int kAFeetFieldNumber = 42;
  inline const ::std::string& a_feet(int index) const;
  inline ::std::string* mutable_a_feet(int index);
  inline void set_a_feet(int index, const ::std::string& value);
  inline void set_a_feet(int index, const char* value);
  inline void set_a_feet(int index, const char* value, size_t size);
  inline ::std::string* add_a_feet();
  inline void add_a_feet(const ::std::string& value);
  inline void add_a_feet(const char* value);
  inline void add_a_feet(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& a_feet() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_a_feet();

  // @@protoc_insertion_point(class_scope:RPG.equips)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> h_head_;
  ::google::protobuf::RepeatedPtrField< ::std::string> h_chest_;
  ::google::protobuf::RepeatedPtrField< ::std::string> h_arm_;
  ::google::protobuf::RepeatedPtrField< ::std::string> h_hand_;
  ::google::protobuf::RepeatedPtrField< ::std::string> h_leg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> h_feet_;
  ::google::protobuf::RepeatedPtrField< ::std::string> l_head_;
  ::google::protobuf::RepeatedPtrField< ::std::string> l_chest_;
  ::google::protobuf::RepeatedPtrField< ::std::string> l_arm_;
  ::google::protobuf::RepeatedPtrField< ::std::string> l_hand_;
  ::google::protobuf::RepeatedPtrField< ::std::string> l_leg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> l_feet_;
  ::google::protobuf::RepeatedPtrField< ::std::string> a_head_;
  ::google::protobuf::RepeatedPtrField< ::std::string> a_chest_;
  ::google::protobuf::RepeatedPtrField< ::std::string> a_arm_;
  ::google::protobuf::RepeatedPtrField< ::std::string> a_hand_;
  ::google::protobuf::RepeatedPtrField< ::std::string> a_leg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> a_feet_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_RPG_2eproto();
  friend void protobuf_AssignDesc_RPG_2eproto();
  friend void protobuf_ShutdownFile_RPG_2eproto();

  void InitAsDefaultInstance();
  static equips* default_instance_;
};
// -------------------------------------------------------------------

class dungeon_setup : public ::google::protobuf::Message {
 public:
  dungeon_setup();
  virtual ~dungeon_setup();

  dungeon_setup(const dungeon_setup& from);

  inline dungeon_setup& operator=(const dungeon_setup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dungeon_setup& default_instance();

  void Swap(dungeon_setup* other);

  // implements Message ----------------------------------------------

  dungeon_setup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dungeon_setup& from);
  void MergeFrom(const dungeon_setup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool isactive = 43;
  inline bool has_isactive() const;
  inline void clear_isactive();
  static const int kIsactiveFieldNumber = 43;
  inline bool isactive() const;
  inline void set_isactive(bool value);

  // optional int32 room_count = 44;
  inline bool has_room_count() const;
  inline void clear_room_count();
  static const int kRoomCountFieldNumber = 44;
  inline ::google::protobuf::int32 room_count() const;
  inline void set_room_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RPG.dungeon_setup)
 private:
  inline void set_has_isactive();
  inline void clear_has_isactive();
  inline void set_has_room_count();
  inline void clear_has_room_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool isactive_;
  ::google::protobuf::int32 room_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RPG_2eproto();
  friend void protobuf_AssignDesc_RPG_2eproto();
  friend void protobuf_ShutdownFile_RPG_2eproto();

  void InitAsDefaultInstance();
  static dungeon_setup* default_instance_;
};
// -------------------------------------------------------------------

class locations : public ::google::protobuf::Message {
 public:
  locations();
  virtual ~locations();

  locations(const locations& from);

  inline locations& operator=(const locations& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const locations& default_instance();

  void Swap(locations* other);

  // implements Message ----------------------------------------------

  locations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const locations& from);
  void MergeFrom(const locations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool first_time_abon = 45;
  inline bool has_first_time_abon() const;
  inline void clear_first_time_abon();
  static const int kFirstTimeAbonFieldNumber = 45;
  inline bool first_time_abon() const;
  inline void set_first_time_abon(bool value);

  // required bool first_time_mon = 46;
  inline bool has_first_time_mon() const;
  inline void clear_first_time_mon();
  static const int kFirstTimeMonFieldNumber = 46;
  inline bool first_time_mon() const;
  inline void set_first_time_mon(bool value);

  // required bool first_time_farm = 47;
  inline bool has_first_time_farm() const;
  inline void clear_first_time_farm();
  static const int kFirstTimeFarmFieldNumber = 47;
  inline bool first_time_farm() const;
  inline void set_first_time_farm(bool value);

  // required bool first_time_boat = 48;
  inline bool has_first_time_boat() const;
  inline void clear_first_time_boat();
  static const int kFirstTimeBoatFieldNumber = 48;
  inline bool first_time_boat() const;
  inline void set_first_time_boat(bool value);

  // optional string rand_house_item = 49;
  inline bool has_rand_house_item() const;
  inline void clear_rand_house_item();
  static const int kRandHouseItemFieldNumber = 49;
  inline const ::std::string& rand_house_item() const;
  inline void set_rand_house_item(const ::std::string& value);
  inline void set_rand_house_item(const char* value);
  inline void set_rand_house_item(const char* value, size_t size);
  inline ::std::string* mutable_rand_house_item();
  inline ::std::string* release_rand_house_item();
  inline void set_allocated_rand_house_item(::std::string* rand_house_item);

  // optional int32 dot_count = 50;
  inline bool has_dot_count() const;
  inline void clear_dot_count();
  static const int kDotCountFieldNumber = 50;
  inline ::google::protobuf::int32 dot_count() const;
  inline void set_dot_count(::google::protobuf::int32 value);

  // optional int32 dot_stop = 51;
  inline bool has_dot_stop() const;
  inline void clear_dot_stop();
  static const int kDotStopFieldNumber = 51;
  inline ::google::protobuf::int32 dot_stop() const;
  inline void set_dot_stop(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RPG.locations)
 private:
  inline void set_has_first_time_abon();
  inline void clear_has_first_time_abon();
  inline void set_has_first_time_mon();
  inline void clear_has_first_time_mon();
  inline void set_has_first_time_farm();
  inline void clear_has_first_time_farm();
  inline void set_has_first_time_boat();
  inline void clear_has_first_time_boat();
  inline void set_has_rand_house_item();
  inline void clear_has_rand_house_item();
  inline void set_has_dot_count();
  inline void clear_has_dot_count();
  inline void set_has_dot_stop();
  inline void clear_has_dot_stop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool first_time_abon_;
  bool first_time_mon_;
  bool first_time_farm_;
  bool first_time_boat_;
  ::google::protobuf::int32 dot_count_;
  ::std::string* rand_house_item_;
  ::google::protobuf::int32 dot_stop_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_RPG_2eproto();
  friend void protobuf_AssignDesc_RPG_2eproto();
  friend void protobuf_ShutdownFile_RPG_2eproto();

  void InitAsDefaultInstance();
  static locations* default_instance_;
};
// -------------------------------------------------------------------

class story : public ::google::protobuf::Message {
 public:
  story();
  virtual ~story();

  story(const story& from);

  inline story& operator=(const story& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const story& default_instance();

  void Swap(story* other);

  // implements Message ----------------------------------------------

  story* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const story& from);
  void MergeFrom(const story& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 progress = 52;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 52;
  inline ::google::protobuf::int32 progress() const;
  inline void set_progress(::google::protobuf::int32 value);

  // required string back_story = 53;
  inline bool has_back_story() const;
  inline void clear_back_story();
  static const int kBackStoryFieldNumber = 53;
  inline const ::std::string& back_story() const;
  inline void set_back_story(const ::std::string& value);
  inline void set_back_story(const char* value);
  inline void set_back_story(const char* value, size_t size);
  inline ::std::string* mutable_back_story();
  inline ::std::string* release_back_story();
  inline void set_allocated_back_story(::std::string* back_story);

  // required string event1 = 54;
  inline bool has_event1() const;
  inline void clear_event1();
  static const int kEvent1FieldNumber = 54;
  inline const ::std::string& event1() const;
  inline void set_event1(const ::std::string& value);
  inline void set_event1(const char* value);
  inline void set_event1(const char* value, size_t size);
  inline ::std::string* mutable_event1();
  inline ::std::string* release_event1();
  inline void set_allocated_event1(::std::string* event1);

  // required string event2 = 55;
  inline bool has_event2() const;
  inline void clear_event2();
  static const int kEvent2FieldNumber = 55;
  inline const ::std::string& event2() const;
  inline void set_event2(const ::std::string& value);
  inline void set_event2(const char* value);
  inline void set_event2(const char* value, size_t size);
  inline ::std::string* mutable_event2();
  inline ::std::string* release_event2();
  inline void set_allocated_event2(::std::string* event2);

  // required string event3 = 56;
  inline bool has_event3() const;
  inline void clear_event3();
  static const int kEvent3FieldNumber = 56;
  inline const ::std::string& event3() const;
  inline void set_event3(const ::std::string& value);
  inline void set_event3(const char* value);
  inline void set_event3(const char* value, size_t size);
  inline ::std::string* mutable_event3();
  inline ::std::string* release_event3();
  inline void set_allocated_event3(::std::string* event3);

  // required string event4 = 57;
  inline bool has_event4() const;
  inline void clear_event4();
  static const int kEvent4FieldNumber = 57;
  inline const ::std::string& event4() const;
  inline void set_event4(const ::std::string& value);
  inline void set_event4(const char* value);
  inline void set_event4(const char* value, size_t size);
  inline ::std::string* mutable_event4();
  inline ::std::string* release_event4();
  inline void set_allocated_event4(::std::string* event4);

  // required string event5 = 58;
  inline bool has_event5() const;
  inline void clear_event5();
  static const int kEvent5FieldNumber = 58;
  inline const ::std::string& event5() const;
  inline void set_event5(const ::std::string& value);
  inline void set_event5(const char* value);
  inline void set_event5(const char* value, size_t size);
  inline ::std::string* mutable_event5();
  inline ::std::string* release_event5();
  inline void set_allocated_event5(::std::string* event5);

  // required string event6 = 59;
  inline bool has_event6() const;
  inline void clear_event6();
  static const int kEvent6FieldNumber = 59;
  inline const ::std::string& event6() const;
  inline void set_event6(const ::std::string& value);
  inline void set_event6(const char* value);
  inline void set_event6(const char* value, size_t size);
  inline ::std::string* mutable_event6();
  inline ::std::string* release_event6();
  inline void set_allocated_event6(::std::string* event6);

  // required string event7 = 60;
  inline bool has_event7() const;
  inline void clear_event7();
  static const int kEvent7FieldNumber = 60;
  inline const ::std::string& event7() const;
  inline void set_event7(const ::std::string& value);
  inline void set_event7(const char* value);
  inline void set_event7(const char* value, size_t size);
  inline ::std::string* mutable_event7();
  inline ::std::string* release_event7();
  inline void set_allocated_event7(::std::string* event7);

  // required string event8 = 61;
  inline bool has_event8() const;
  inline void clear_event8();
  static const int kEvent8FieldNumber = 61;
  inline const ::std::string& event8() const;
  inline void set_event8(const ::std::string& value);
  inline void set_event8(const char* value);
  inline void set_event8(const char* value, size_t size);
  inline ::std::string* mutable_event8();
  inline ::std::string* release_event8();
  inline void set_allocated_event8(::std::string* event8);

  // required string event9 = 62;
  inline bool has_event9() const;
  inline void clear_event9();
  static const int kEvent9FieldNumber = 62;
  inline const ::std::string& event9() const;
  inline void set_event9(const ::std::string& value);
  inline void set_event9(const char* value);
  inline void set_event9(const char* value, size_t size);
  inline ::std::string* mutable_event9();
  inline ::std::string* release_event9();
  inline void set_allocated_event9(::std::string* event9);

  // required string event10 = 63;
  inline bool has_event10() const;
  inline void clear_event10();
  static const int kEvent10FieldNumber = 63;
  inline const ::std::string& event10() const;
  inline void set_event10(const ::std::string& value);
  inline void set_event10(const char* value);
  inline void set_event10(const char* value, size_t size);
  inline ::std::string* mutable_event10();
  inline ::std::string* release_event10();
  inline void set_allocated_event10(::std::string* event10);

  // @@protoc_insertion_point(class_scope:RPG.story)
 private:
  inline void set_has_progress();
  inline void clear_has_progress();
  inline void set_has_back_story();
  inline void clear_has_back_story();
  inline void set_has_event1();
  inline void clear_has_event1();
  inline void set_has_event2();
  inline void clear_has_event2();
  inline void set_has_event3();
  inline void clear_has_event3();
  inline void set_has_event4();
  inline void clear_has_event4();
  inline void set_has_event5();
  inline void clear_has_event5();
  inline void set_has_event6();
  inline void clear_has_event6();
  inline void set_has_event7();
  inline void clear_has_event7();
  inline void set_has_event8();
  inline void clear_has_event8();
  inline void set_has_event9();
  inline void clear_has_event9();
  inline void set_has_event10();
  inline void clear_has_event10();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* back_story_;
  ::std::string* event1_;
  ::std::string* event2_;
  ::std::string* event3_;
  ::std::string* event4_;
  ::std::string* event5_;
  ::std::string* event6_;
  ::std::string* event7_;
  ::std::string* event8_;
  ::std::string* event9_;
  ::std::string* event10_;
  ::google::protobuf::int32 progress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_RPG_2eproto();
  friend void protobuf_AssignDesc_RPG_2eproto();
  friend void protobuf_ShutdownFile_RPG_2eproto();

  void InitAsDefaultInstance();
  static story* default_instance_;
};
// ===================================================================


// ===================================================================

// player

// required int32 money = 1;
inline bool player::has_money() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void player::set_has_money() {
  _has_bits_[0] |= 0x00000001u;
}
inline void player::clear_has_money() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void player::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 player::money() const {
  return money_;
}
inline void player::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// required string race_class = 2;
inline bool player::has_race_class() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void player::set_has_race_class() {
  _has_bits_[0] |= 0x00000002u;
}
inline void player::clear_has_race_class() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void player::clear_race_class() {
  if (race_class_ != &::google::protobuf::internal::kEmptyString) {
    race_class_->clear();
  }
  clear_has_race_class();
}
inline const ::std::string& player::race_class() const {
  return *race_class_;
}
inline void player::set_race_class(const ::std::string& value) {
  set_has_race_class();
  if (race_class_ == &::google::protobuf::internal::kEmptyString) {
    race_class_ = new ::std::string;
  }
  race_class_->assign(value);
}
inline void player::set_race_class(const char* value) {
  set_has_race_class();
  if (race_class_ == &::google::protobuf::internal::kEmptyString) {
    race_class_ = new ::std::string;
  }
  race_class_->assign(value);
}
inline void player::set_race_class(const char* value, size_t size) {
  set_has_race_class();
  if (race_class_ == &::google::protobuf::internal::kEmptyString) {
    race_class_ = new ::std::string;
  }
  race_class_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* player::mutable_race_class() {
  set_has_race_class();
  if (race_class_ == &::google::protobuf::internal::kEmptyString) {
    race_class_ = new ::std::string;
  }
  return race_class_;
}
inline ::std::string* player::release_race_class() {
  clear_has_race_class();
  if (race_class_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = race_class_;
    race_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void player::set_allocated_race_class(::std::string* race_class) {
  if (race_class_ != &::google::protobuf::internal::kEmptyString) {
    delete race_class_;
  }
  if (race_class) {
    set_has_race_class();
    race_class_ = race_class;
  } else {
    clear_has_race_class();
    race_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 health = 3;
inline bool player::has_health() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void player::set_has_health() {
  _has_bits_[0] |= 0x00000004u;
}
inline void player::clear_has_health() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void player::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline ::google::protobuf::int32 player::health() const {
  return health_;
}
inline void player::set_health(::google::protobuf::int32 value) {
  set_has_health();
  health_ = value;
}

// required int32 max_health = 4;
inline bool player::has_max_health() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void player::set_has_max_health() {
  _has_bits_[0] |= 0x00000008u;
}
inline void player::clear_has_max_health() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void player::clear_max_health() {
  max_health_ = 0;
  clear_has_max_health();
}
inline ::google::protobuf::int32 player::max_health() const {
  return max_health_;
}
inline void player::set_max_health(::google::protobuf::int32 value) {
  set_has_max_health();
  max_health_ = value;
}

// required int32 exp = 5;
inline bool player::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void player::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void player::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void player::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 player::exp() const {
  return exp_;
}
inline void player::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// required int32 level = 6;
inline bool player::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void player::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void player::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void player::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 player::level() const {
  return level_;
}
inline void player::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 dmg = 7;
inline bool player::has_dmg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void player::set_has_dmg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void player::clear_has_dmg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void player::clear_dmg() {
  dmg_ = 0;
  clear_has_dmg();
}
inline ::google::protobuf::int32 player::dmg() const {
  return dmg_;
}
inline void player::set_dmg(::google::protobuf::int32 value) {
  set_has_dmg();
  dmg_ = value;
}

// required string player_class = 8;
inline bool player::has_player_class() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void player::set_has_player_class() {
  _has_bits_[0] |= 0x00000080u;
}
inline void player::clear_has_player_class() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void player::clear_player_class() {
  if (player_class_ != &::google::protobuf::internal::kEmptyString) {
    player_class_->clear();
  }
  clear_has_player_class();
}
inline const ::std::string& player::player_class() const {
  return *player_class_;
}
inline void player::set_player_class(const ::std::string& value) {
  set_has_player_class();
  if (player_class_ == &::google::protobuf::internal::kEmptyString) {
    player_class_ = new ::std::string;
  }
  player_class_->assign(value);
}
inline void player::set_player_class(const char* value) {
  set_has_player_class();
  if (player_class_ == &::google::protobuf::internal::kEmptyString) {
    player_class_ = new ::std::string;
  }
  player_class_->assign(value);
}
inline void player::set_player_class(const char* value, size_t size) {
  set_has_player_class();
  if (player_class_ == &::google::protobuf::internal::kEmptyString) {
    player_class_ = new ::std::string;
  }
  player_class_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* player::mutable_player_class() {
  set_has_player_class();
  if (player_class_ == &::google::protobuf::internal::kEmptyString) {
    player_class_ = new ::std::string;
  }
  return player_class_;
}
inline ::std::string* player::release_player_class() {
  clear_has_player_class();
  if (player_class_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = player_class_;
    player_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void player::set_allocated_player_class(::std::string* player_class) {
  if (player_class_ != &::google::protobuf::internal::kEmptyString) {
    delete player_class_;
  }
  if (player_class) {
    set_has_player_class();
    player_class_ = player_class;
  } else {
    clear_has_player_class();
    player_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string inventory = 9;
inline int player::inventory_size() const {
  return inventory_.size();
}
inline void player::clear_inventory() {
  inventory_.Clear();
}
inline const ::std::string& player::inventory(int index) const {
  return inventory_.Get(index);
}
inline ::std::string* player::mutable_inventory(int index) {
  return inventory_.Mutable(index);
}
inline void player::set_inventory(int index, const ::std::string& value) {
  inventory_.Mutable(index)->assign(value);
}
inline void player::set_inventory(int index, const char* value) {
  inventory_.Mutable(index)->assign(value);
}
inline void player::set_inventory(int index, const char* value, size_t size) {
  inventory_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* player::add_inventory() {
  return inventory_.Add();
}
inline void player::add_inventory(const ::std::string& value) {
  inventory_.Add()->assign(value);
}
inline void player::add_inventory(const char* value) {
  inventory_.Add()->assign(value);
}
inline void player::add_inventory(const char* value, size_t size) {
  inventory_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
player::inventory() const {
  return inventory_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
player::mutable_inventory() {
  return &inventory_;
}

// repeated string equip_places_key = 10;
inline int player::equip_places_key_size() const {
  return equip_places_key_.size();
}
inline void player::clear_equip_places_key() {
  equip_places_key_.Clear();
}
inline const ::std::string& player::equip_places_key(int index) const {
  return equip_places_key_.Get(index);
}
inline ::std::string* player::mutable_equip_places_key(int index) {
  return equip_places_key_.Mutable(index);
}
inline void player::set_equip_places_key(int index, const ::std::string& value) {
  equip_places_key_.Mutable(index)->assign(value);
}
inline void player::set_equip_places_key(int index, const char* value) {
  equip_places_key_.Mutable(index)->assign(value);
}
inline void player::set_equip_places_key(int index, const char* value, size_t size) {
  equip_places_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* player::add_equip_places_key() {
  return equip_places_key_.Add();
}
inline void player::add_equip_places_key(const ::std::string& value) {
  equip_places_key_.Add()->assign(value);
}
inline void player::add_equip_places_key(const char* value) {
  equip_places_key_.Add()->assign(value);
}
inline void player::add_equip_places_key(const char* value, size_t size) {
  equip_places_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
player::equip_places_key() const {
  return equip_places_key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
player::mutable_equip_places_key() {
  return &equip_places_key_;
}

// repeated string equip_places_value = 11;
inline int player::equip_places_value_size() const {
  return equip_places_value_.size();
}
inline void player::clear_equip_places_value() {
  equip_places_value_.Clear();
}
inline const ::std::string& player::equip_places_value(int index) const {
  return equip_places_value_.Get(index);
}
inline ::std::string* player::mutable_equip_places_value(int index) {
  return equip_places_value_.Mutable(index);
}
inline void player::set_equip_places_value(int index, const ::std::string& value) {
  equip_places_value_.Mutable(index)->assign(value);
}
inline void player::set_equip_places_value(int index, const char* value) {
  equip_places_value_.Mutable(index)->assign(value);
}
inline void player::set_equip_places_value(int index, const char* value, size_t size) {
  equip_places_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* player::add_equip_places_value() {
  return equip_places_value_.Add();
}
inline void player::add_equip_places_value(const ::std::string& value) {
  equip_places_value_.Add()->assign(value);
}
inline void player::add_equip_places_value(const char* value) {
  equip_places_value_.Add()->assign(value);
}
inline void player::add_equip_places_value(const char* value, size_t size) {
  equip_places_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
player::equip_places_value() const {
  return equip_places_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
player::mutable_equip_places_value() {
  return &equip_places_value_;
}

// -------------------------------------------------------------------

// npc

// repeated string smith_items_to_buy_key = 12;
inline int npc::smith_items_to_buy_key_size() const {
  return smith_items_to_buy_key_.size();
}
inline void npc::clear_smith_items_to_buy_key() {
  smith_items_to_buy_key_.Clear();
}
inline const ::std::string& npc::smith_items_to_buy_key(int index) const {
  return smith_items_to_buy_key_.Get(index);
}
inline ::std::string* npc::mutable_smith_items_to_buy_key(int index) {
  return smith_items_to_buy_key_.Mutable(index);
}
inline void npc::set_smith_items_to_buy_key(int index, const ::std::string& value) {
  smith_items_to_buy_key_.Mutable(index)->assign(value);
}
inline void npc::set_smith_items_to_buy_key(int index, const char* value) {
  smith_items_to_buy_key_.Mutable(index)->assign(value);
}
inline void npc::set_smith_items_to_buy_key(int index, const char* value, size_t size) {
  smith_items_to_buy_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* npc::add_smith_items_to_buy_key() {
  return smith_items_to_buy_key_.Add();
}
inline void npc::add_smith_items_to_buy_key(const ::std::string& value) {
  smith_items_to_buy_key_.Add()->assign(value);
}
inline void npc::add_smith_items_to_buy_key(const char* value) {
  smith_items_to_buy_key_.Add()->assign(value);
}
inline void npc::add_smith_items_to_buy_key(const char* value, size_t size) {
  smith_items_to_buy_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
npc::smith_items_to_buy_key() const {
  return smith_items_to_buy_key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
npc::mutable_smith_items_to_buy_key() {
  return &smith_items_to_buy_key_;
}

// repeated int32 smith_items_to_buy_value = 13;
inline int npc::smith_items_to_buy_value_size() const {
  return smith_items_to_buy_value_.size();
}
inline void npc::clear_smith_items_to_buy_value() {
  smith_items_to_buy_value_.Clear();
}
inline ::google::protobuf::int32 npc::smith_items_to_buy_value(int index) const {
  return smith_items_to_buy_value_.Get(index);
}
inline void npc::set_smith_items_to_buy_value(int index, ::google::protobuf::int32 value) {
  smith_items_to_buy_value_.Set(index, value);
}
inline void npc::add_smith_items_to_buy_value(::google::protobuf::int32 value) {
  smith_items_to_buy_value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
npc::smith_items_to_buy_value() const {
  return smith_items_to_buy_value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
npc::mutable_smith_items_to_buy_value() {
  return &smith_items_to_buy_value_;
}

// repeated string smith_items_to_sell_key = 14;
inline int npc::smith_items_to_sell_key_size() const {
  return smith_items_to_sell_key_.size();
}
inline void npc::clear_smith_items_to_sell_key() {
  smith_items_to_sell_key_.Clear();
}
inline const ::std::string& npc::smith_items_to_sell_key(int index) const {
  return smith_items_to_sell_key_.Get(index);
}
inline ::std::string* npc::mutable_smith_items_to_sell_key(int index) {
  return smith_items_to_sell_key_.Mutable(index);
}
inline void npc::set_smith_items_to_sell_key(int index, const ::std::string& value) {
  smith_items_to_sell_key_.Mutable(index)->assign(value);
}
inline void npc::set_smith_items_to_sell_key(int index, const char* value) {
  smith_items_to_sell_key_.Mutable(index)->assign(value);
}
inline void npc::set_smith_items_to_sell_key(int index, const char* value, size_t size) {
  smith_items_to_sell_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* npc::add_smith_items_to_sell_key() {
  return smith_items_to_sell_key_.Add();
}
inline void npc::add_smith_items_to_sell_key(const ::std::string& value) {
  smith_items_to_sell_key_.Add()->assign(value);
}
inline void npc::add_smith_items_to_sell_key(const char* value) {
  smith_items_to_sell_key_.Add()->assign(value);
}
inline void npc::add_smith_items_to_sell_key(const char* value, size_t size) {
  smith_items_to_sell_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
npc::smith_items_to_sell_key() const {
  return smith_items_to_sell_key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
npc::mutable_smith_items_to_sell_key() {
  return &smith_items_to_sell_key_;
}

// repeated int32 smith_items_to_sell_value = 15;
inline int npc::smith_items_to_sell_value_size() const {
  return smith_items_to_sell_value_.size();
}
inline void npc::clear_smith_items_to_sell_value() {
  smith_items_to_sell_value_.Clear();
}
inline ::google::protobuf::int32 npc::smith_items_to_sell_value(int index) const {
  return smith_items_to_sell_value_.Get(index);
}
inline void npc::set_smith_items_to_sell_value(int index, ::google::protobuf::int32 value) {
  smith_items_to_sell_value_.Set(index, value);
}
inline void npc::add_smith_items_to_sell_value(::google::protobuf::int32 value) {
  smith_items_to_sell_value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
npc::smith_items_to_sell_value() const {
  return smith_items_to_sell_value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
npc::mutable_smith_items_to_sell_value() {
  return &smith_items_to_sell_value_;
}

// -------------------------------------------------------------------

// use_item

// optional string picked_potion = 16;
inline bool use_item::has_picked_potion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void use_item::set_has_picked_potion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void use_item::clear_has_picked_potion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void use_item::clear_picked_potion() {
  if (picked_potion_ != &::google::protobuf::internal::kEmptyString) {
    picked_potion_->clear();
  }
  clear_has_picked_potion();
}
inline const ::std::string& use_item::picked_potion() const {
  return *picked_potion_;
}
inline void use_item::set_picked_potion(const ::std::string& value) {
  set_has_picked_potion();
  if (picked_potion_ == &::google::protobuf::internal::kEmptyString) {
    picked_potion_ = new ::std::string;
  }
  picked_potion_->assign(value);
}
inline void use_item::set_picked_potion(const char* value) {
  set_has_picked_potion();
  if (picked_potion_ == &::google::protobuf::internal::kEmptyString) {
    picked_potion_ = new ::std::string;
  }
  picked_potion_->assign(value);
}
inline void use_item::set_picked_potion(const char* value, size_t size) {
  set_has_picked_potion();
  if (picked_potion_ == &::google::protobuf::internal::kEmptyString) {
    picked_potion_ = new ::std::string;
  }
  picked_potion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* use_item::mutable_picked_potion() {
  set_has_picked_potion();
  if (picked_potion_ == &::google::protobuf::internal::kEmptyString) {
    picked_potion_ = new ::std::string;
  }
  return picked_potion_;
}
inline ::std::string* use_item::release_picked_potion() {
  clear_has_picked_potion();
  if (picked_potion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picked_potion_;
    picked_potion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void use_item::set_allocated_picked_potion(::std::string* picked_potion) {
  if (picked_potion_ != &::google::protobuf::internal::kEmptyString) {
    delete picked_potion_;
  }
  if (picked_potion) {
    set_has_picked_potion();
    picked_potion_ = picked_potion;
  } else {
    clear_has_picked_potion();
    picked_potion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 wear_off = 17;
inline bool use_item::has_wear_off() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void use_item::set_has_wear_off() {
  _has_bits_[0] |= 0x00000002u;
}
inline void use_item::clear_has_wear_off() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void use_item::clear_wear_off() {
  wear_off_ = 0;
  clear_has_wear_off();
}
inline ::google::protobuf::int32 use_item::wear_off() const {
  return wear_off_;
}
inline void use_item::set_wear_off(::google::protobuf::int32 value) {
  set_has_wear_off();
  wear_off_ = value;
}

// repeated string health_restores = 18;
inline int use_item::health_restores_size() const {
  return health_restores_.size();
}
inline void use_item::clear_health_restores() {
  health_restores_.Clear();
}
inline const ::std::string& use_item::health_restores(int index) const {
  return health_restores_.Get(index);
}
inline ::std::string* use_item::mutable_health_restores(int index) {
  return health_restores_.Mutable(index);
}
inline void use_item::set_health_restores(int index, const ::std::string& value) {
  health_restores_.Mutable(index)->assign(value);
}
inline void use_item::set_health_restores(int index, const char* value) {
  health_restores_.Mutable(index)->assign(value);
}
inline void use_item::set_health_restores(int index, const char* value, size_t size) {
  health_restores_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* use_item::add_health_restores() {
  return health_restores_.Add();
}
inline void use_item::add_health_restores(const ::std::string& value) {
  health_restores_.Add()->assign(value);
}
inline void use_item::add_health_restores(const char* value) {
  health_restores_.Add()->assign(value);
}
inline void use_item::add_health_restores(const char* value, size_t size) {
  health_restores_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
use_item::health_restores() const {
  return health_restores_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
use_item::mutable_health_restores() {
  return &health_restores_;
}

// repeated string poisons = 19;
inline int use_item::poisons_size() const {
  return poisons_.size();
}
inline void use_item::clear_poisons() {
  poisons_.Clear();
}
inline const ::std::string& use_item::poisons(int index) const {
  return poisons_.Get(index);
}
inline ::std::string* use_item::mutable_poisons(int index) {
  return poisons_.Mutable(index);
}
inline void use_item::set_poisons(int index, const ::std::string& value) {
  poisons_.Mutable(index)->assign(value);
}
inline void use_item::set_poisons(int index, const char* value) {
  poisons_.Mutable(index)->assign(value);
}
inline void use_item::set_poisons(int index, const char* value, size_t size) {
  poisons_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* use_item::add_poisons() {
  return poisons_.Add();
}
inline void use_item::add_poisons(const ::std::string& value) {
  poisons_.Add()->assign(value);
}
inline void use_item::add_poisons(const char* value) {
  poisons_.Add()->assign(value);
}
inline void use_item::add_poisons(const char* value, size_t size) {
  poisons_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
use_item::poisons() const {
  return poisons_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
use_item::mutable_poisons() {
  return &poisons_;
}

// repeated string temp_boosts = 20;
inline int use_item::temp_boosts_size() const {
  return temp_boosts_.size();
}
inline void use_item::clear_temp_boosts() {
  temp_boosts_.Clear();
}
inline const ::std::string& use_item::temp_boosts(int index) const {
  return temp_boosts_.Get(index);
}
inline ::std::string* use_item::mutable_temp_boosts(int index) {
  return temp_boosts_.Mutable(index);
}
inline void use_item::set_temp_boosts(int index, const ::std::string& value) {
  temp_boosts_.Mutable(index)->assign(value);
}
inline void use_item::set_temp_boosts(int index, const char* value) {
  temp_boosts_.Mutable(index)->assign(value);
}
inline void use_item::set_temp_boosts(int index, const char* value, size_t size) {
  temp_boosts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* use_item::add_temp_boosts() {
  return temp_boosts_.Add();
}
inline void use_item::add_temp_boosts(const ::std::string& value) {
  temp_boosts_.Add()->assign(value);
}
inline void use_item::add_temp_boosts(const char* value) {
  temp_boosts_.Add()->assign(value);
}
inline void use_item::add_temp_boosts(const char* value, size_t size) {
  temp_boosts_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
use_item::temp_boosts() const {
  return temp_boosts_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
use_item::mutable_temp_boosts() {
  return &temp_boosts_;
}

// repeated string perm_boosts = 21;
inline int use_item::perm_boosts_size() const {
  return perm_boosts_.size();
}
inline void use_item::clear_perm_boosts() {
  perm_boosts_.Clear();
}
inline const ::std::string& use_item::perm_boosts(int index) const {
  return perm_boosts_.Get(index);
}
inline ::std::string* use_item::mutable_perm_boosts(int index) {
  return perm_boosts_.Mutable(index);
}
inline void use_item::set_perm_boosts(int index, const ::std::string& value) {
  perm_boosts_.Mutable(index)->assign(value);
}
inline void use_item::set_perm_boosts(int index, const char* value) {
  perm_boosts_.Mutable(index)->assign(value);
}
inline void use_item::set_perm_boosts(int index, const char* value, size_t size) {
  perm_boosts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* use_item::add_perm_boosts() {
  return perm_boosts_.Add();
}
inline void use_item::add_perm_boosts(const ::std::string& value) {
  perm_boosts_.Add()->assign(value);
}
inline void use_item::add_perm_boosts(const char* value) {
  perm_boosts_.Add()->assign(value);
}
inline void use_item::add_perm_boosts(const char* value, size_t size) {
  perm_boosts_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
use_item::perm_boosts() const {
  return perm_boosts_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
use_item::mutable_perm_boosts() {
  return &perm_boosts_;
}

// repeated string misc = 22;
inline int use_item::misc_size() const {
  return misc_.size();
}
inline void use_item::clear_misc() {
  misc_.Clear();
}
inline const ::std::string& use_item::misc(int index) const {
  return misc_.Get(index);
}
inline ::std::string* use_item::mutable_misc(int index) {
  return misc_.Mutable(index);
}
inline void use_item::set_misc(int index, const ::std::string& value) {
  misc_.Mutable(index)->assign(value);
}
inline void use_item::set_misc(int index, const char* value) {
  misc_.Mutable(index)->assign(value);
}
inline void use_item::set_misc(int index, const char* value, size_t size) {
  misc_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* use_item::add_misc() {
  return misc_.Add();
}
inline void use_item::add_misc(const ::std::string& value) {
  misc_.Add()->assign(value);
}
inline void use_item::add_misc(const char* value) {
  misc_.Add()->assign(value);
}
inline void use_item::add_misc(const char* value, size_t size) {
  misc_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
use_item::misc() const {
  return misc_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
use_item::mutable_misc() {
  return &misc_;
}

// -------------------------------------------------------------------

// monster

// repeated string mon_count = 23;
inline int monster::mon_count_size() const {
  return mon_count_.size();
}
inline void monster::clear_mon_count() {
  mon_count_.Clear();
}
inline const ::std::string& monster::mon_count(int index) const {
  return mon_count_.Get(index);
}
inline ::std::string* monster::mutable_mon_count(int index) {
  return mon_count_.Mutable(index);
}
inline void monster::set_mon_count(int index, const ::std::string& value) {
  mon_count_.Mutable(index)->assign(value);
}
inline void monster::set_mon_count(int index, const char* value) {
  mon_count_.Mutable(index)->assign(value);
}
inline void monster::set_mon_count(int index, const char* value, size_t size) {
  mon_count_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* monster::add_mon_count() {
  return mon_count_.Add();
}
inline void monster::add_mon_count(const ::std::string& value) {
  mon_count_.Add()->assign(value);
}
inline void monster::add_mon_count(const char* value) {
  mon_count_.Add()->assign(value);
}
inline void monster::add_mon_count(const char* value, size_t size) {
  mon_count_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
monster::mon_count() const {
  return mon_count_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
monster::mutable_mon_count() {
  return &mon_count_;
}

// required int32 mon_level = 24;
inline bool monster::has_mon_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void monster::set_has_mon_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void monster::clear_has_mon_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void monster::clear_mon_level() {
  mon_level_ = 0;
  clear_has_mon_level();
}
inline ::google::protobuf::int32 monster::mon_level() const {
  return mon_level_;
}
inline void monster::set_mon_level(::google::protobuf::int32 value) {
  set_has_mon_level();
  mon_level_ = value;
}

// -------------------------------------------------------------------

// equips

// repeated string h_head = 25;
inline int equips::h_head_size() const {
  return h_head_.size();
}
inline void equips::clear_h_head() {
  h_head_.Clear();
}
inline const ::std::string& equips::h_head(int index) const {
  return h_head_.Get(index);
}
inline ::std::string* equips::mutable_h_head(int index) {
  return h_head_.Mutable(index);
}
inline void equips::set_h_head(int index, const ::std::string& value) {
  h_head_.Mutable(index)->assign(value);
}
inline void equips::set_h_head(int index, const char* value) {
  h_head_.Mutable(index)->assign(value);
}
inline void equips::set_h_head(int index, const char* value, size_t size) {
  h_head_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_h_head() {
  return h_head_.Add();
}
inline void equips::add_h_head(const ::std::string& value) {
  h_head_.Add()->assign(value);
}
inline void equips::add_h_head(const char* value) {
  h_head_.Add()->assign(value);
}
inline void equips::add_h_head(const char* value, size_t size) {
  h_head_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::h_head() const {
  return h_head_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_h_head() {
  return &h_head_;
}

// repeated string h_chest = 26;
inline int equips::h_chest_size() const {
  return h_chest_.size();
}
inline void equips::clear_h_chest() {
  h_chest_.Clear();
}
inline const ::std::string& equips::h_chest(int index) const {
  return h_chest_.Get(index);
}
inline ::std::string* equips::mutable_h_chest(int index) {
  return h_chest_.Mutable(index);
}
inline void equips::set_h_chest(int index, const ::std::string& value) {
  h_chest_.Mutable(index)->assign(value);
}
inline void equips::set_h_chest(int index, const char* value) {
  h_chest_.Mutable(index)->assign(value);
}
inline void equips::set_h_chest(int index, const char* value, size_t size) {
  h_chest_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_h_chest() {
  return h_chest_.Add();
}
inline void equips::add_h_chest(const ::std::string& value) {
  h_chest_.Add()->assign(value);
}
inline void equips::add_h_chest(const char* value) {
  h_chest_.Add()->assign(value);
}
inline void equips::add_h_chest(const char* value, size_t size) {
  h_chest_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::h_chest() const {
  return h_chest_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_h_chest() {
  return &h_chest_;
}

// repeated string h_arm = 27;
inline int equips::h_arm_size() const {
  return h_arm_.size();
}
inline void equips::clear_h_arm() {
  h_arm_.Clear();
}
inline const ::std::string& equips::h_arm(int index) const {
  return h_arm_.Get(index);
}
inline ::std::string* equips::mutable_h_arm(int index) {
  return h_arm_.Mutable(index);
}
inline void equips::set_h_arm(int index, const ::std::string& value) {
  h_arm_.Mutable(index)->assign(value);
}
inline void equips::set_h_arm(int index, const char* value) {
  h_arm_.Mutable(index)->assign(value);
}
inline void equips::set_h_arm(int index, const char* value, size_t size) {
  h_arm_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_h_arm() {
  return h_arm_.Add();
}
inline void equips::add_h_arm(const ::std::string& value) {
  h_arm_.Add()->assign(value);
}
inline void equips::add_h_arm(const char* value) {
  h_arm_.Add()->assign(value);
}
inline void equips::add_h_arm(const char* value, size_t size) {
  h_arm_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::h_arm() const {
  return h_arm_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_h_arm() {
  return &h_arm_;
}

// repeated string h_hand = 28;
inline int equips::h_hand_size() const {
  return h_hand_.size();
}
inline void equips::clear_h_hand() {
  h_hand_.Clear();
}
inline const ::std::string& equips::h_hand(int index) const {
  return h_hand_.Get(index);
}
inline ::std::string* equips::mutable_h_hand(int index) {
  return h_hand_.Mutable(index);
}
inline void equips::set_h_hand(int index, const ::std::string& value) {
  h_hand_.Mutable(index)->assign(value);
}
inline void equips::set_h_hand(int index, const char* value) {
  h_hand_.Mutable(index)->assign(value);
}
inline void equips::set_h_hand(int index, const char* value, size_t size) {
  h_hand_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_h_hand() {
  return h_hand_.Add();
}
inline void equips::add_h_hand(const ::std::string& value) {
  h_hand_.Add()->assign(value);
}
inline void equips::add_h_hand(const char* value) {
  h_hand_.Add()->assign(value);
}
inline void equips::add_h_hand(const char* value, size_t size) {
  h_hand_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::h_hand() const {
  return h_hand_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_h_hand() {
  return &h_hand_;
}

// repeated string h_leg = 29;
inline int equips::h_leg_size() const {
  return h_leg_.size();
}
inline void equips::clear_h_leg() {
  h_leg_.Clear();
}
inline const ::std::string& equips::h_leg(int index) const {
  return h_leg_.Get(index);
}
inline ::std::string* equips::mutable_h_leg(int index) {
  return h_leg_.Mutable(index);
}
inline void equips::set_h_leg(int index, const ::std::string& value) {
  h_leg_.Mutable(index)->assign(value);
}
inline void equips::set_h_leg(int index, const char* value) {
  h_leg_.Mutable(index)->assign(value);
}
inline void equips::set_h_leg(int index, const char* value, size_t size) {
  h_leg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_h_leg() {
  return h_leg_.Add();
}
inline void equips::add_h_leg(const ::std::string& value) {
  h_leg_.Add()->assign(value);
}
inline void equips::add_h_leg(const char* value) {
  h_leg_.Add()->assign(value);
}
inline void equips::add_h_leg(const char* value, size_t size) {
  h_leg_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::h_leg() const {
  return h_leg_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_h_leg() {
  return &h_leg_;
}

// repeated string h_feet = 30;
inline int equips::h_feet_size() const {
  return h_feet_.size();
}
inline void equips::clear_h_feet() {
  h_feet_.Clear();
}
inline const ::std::string& equips::h_feet(int index) const {
  return h_feet_.Get(index);
}
inline ::std::string* equips::mutable_h_feet(int index) {
  return h_feet_.Mutable(index);
}
inline void equips::set_h_feet(int index, const ::std::string& value) {
  h_feet_.Mutable(index)->assign(value);
}
inline void equips::set_h_feet(int index, const char* value) {
  h_feet_.Mutable(index)->assign(value);
}
inline void equips::set_h_feet(int index, const char* value, size_t size) {
  h_feet_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_h_feet() {
  return h_feet_.Add();
}
inline void equips::add_h_feet(const ::std::string& value) {
  h_feet_.Add()->assign(value);
}
inline void equips::add_h_feet(const char* value) {
  h_feet_.Add()->assign(value);
}
inline void equips::add_h_feet(const char* value, size_t size) {
  h_feet_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::h_feet() const {
  return h_feet_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_h_feet() {
  return &h_feet_;
}

// repeated string l_head = 31;
inline int equips::l_head_size() const {
  return l_head_.size();
}
inline void equips::clear_l_head() {
  l_head_.Clear();
}
inline const ::std::string& equips::l_head(int index) const {
  return l_head_.Get(index);
}
inline ::std::string* equips::mutable_l_head(int index) {
  return l_head_.Mutable(index);
}
inline void equips::set_l_head(int index, const ::std::string& value) {
  l_head_.Mutable(index)->assign(value);
}
inline void equips::set_l_head(int index, const char* value) {
  l_head_.Mutable(index)->assign(value);
}
inline void equips::set_l_head(int index, const char* value, size_t size) {
  l_head_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_l_head() {
  return l_head_.Add();
}
inline void equips::add_l_head(const ::std::string& value) {
  l_head_.Add()->assign(value);
}
inline void equips::add_l_head(const char* value) {
  l_head_.Add()->assign(value);
}
inline void equips::add_l_head(const char* value, size_t size) {
  l_head_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::l_head() const {
  return l_head_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_l_head() {
  return &l_head_;
}

// repeated string l_chest = 32;
inline int equips::l_chest_size() const {
  return l_chest_.size();
}
inline void equips::clear_l_chest() {
  l_chest_.Clear();
}
inline const ::std::string& equips::l_chest(int index) const {
  return l_chest_.Get(index);
}
inline ::std::string* equips::mutable_l_chest(int index) {
  return l_chest_.Mutable(index);
}
inline void equips::set_l_chest(int index, const ::std::string& value) {
  l_chest_.Mutable(index)->assign(value);
}
inline void equips::set_l_chest(int index, const char* value) {
  l_chest_.Mutable(index)->assign(value);
}
inline void equips::set_l_chest(int index, const char* value, size_t size) {
  l_chest_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_l_chest() {
  return l_chest_.Add();
}
inline void equips::add_l_chest(const ::std::string& value) {
  l_chest_.Add()->assign(value);
}
inline void equips::add_l_chest(const char* value) {
  l_chest_.Add()->assign(value);
}
inline void equips::add_l_chest(const char* value, size_t size) {
  l_chest_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::l_chest() const {
  return l_chest_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_l_chest() {
  return &l_chest_;
}

// repeated string l_arm = 33;
inline int equips::l_arm_size() const {
  return l_arm_.size();
}
inline void equips::clear_l_arm() {
  l_arm_.Clear();
}
inline const ::std::string& equips::l_arm(int index) const {
  return l_arm_.Get(index);
}
inline ::std::string* equips::mutable_l_arm(int index) {
  return l_arm_.Mutable(index);
}
inline void equips::set_l_arm(int index, const ::std::string& value) {
  l_arm_.Mutable(index)->assign(value);
}
inline void equips::set_l_arm(int index, const char* value) {
  l_arm_.Mutable(index)->assign(value);
}
inline void equips::set_l_arm(int index, const char* value, size_t size) {
  l_arm_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_l_arm() {
  return l_arm_.Add();
}
inline void equips::add_l_arm(const ::std::string& value) {
  l_arm_.Add()->assign(value);
}
inline void equips::add_l_arm(const char* value) {
  l_arm_.Add()->assign(value);
}
inline void equips::add_l_arm(const char* value, size_t size) {
  l_arm_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::l_arm() const {
  return l_arm_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_l_arm() {
  return &l_arm_;
}

// repeated string l_hand = 34;
inline int equips::l_hand_size() const {
  return l_hand_.size();
}
inline void equips::clear_l_hand() {
  l_hand_.Clear();
}
inline const ::std::string& equips::l_hand(int index) const {
  return l_hand_.Get(index);
}
inline ::std::string* equips::mutable_l_hand(int index) {
  return l_hand_.Mutable(index);
}
inline void equips::set_l_hand(int index, const ::std::string& value) {
  l_hand_.Mutable(index)->assign(value);
}
inline void equips::set_l_hand(int index, const char* value) {
  l_hand_.Mutable(index)->assign(value);
}
inline void equips::set_l_hand(int index, const char* value, size_t size) {
  l_hand_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_l_hand() {
  return l_hand_.Add();
}
inline void equips::add_l_hand(const ::std::string& value) {
  l_hand_.Add()->assign(value);
}
inline void equips::add_l_hand(const char* value) {
  l_hand_.Add()->assign(value);
}
inline void equips::add_l_hand(const char* value, size_t size) {
  l_hand_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::l_hand() const {
  return l_hand_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_l_hand() {
  return &l_hand_;
}

// repeated string l_leg = 35;
inline int equips::l_leg_size() const {
  return l_leg_.size();
}
inline void equips::clear_l_leg() {
  l_leg_.Clear();
}
inline const ::std::string& equips::l_leg(int index) const {
  return l_leg_.Get(index);
}
inline ::std::string* equips::mutable_l_leg(int index) {
  return l_leg_.Mutable(index);
}
inline void equips::set_l_leg(int index, const ::std::string& value) {
  l_leg_.Mutable(index)->assign(value);
}
inline void equips::set_l_leg(int index, const char* value) {
  l_leg_.Mutable(index)->assign(value);
}
inline void equips::set_l_leg(int index, const char* value, size_t size) {
  l_leg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_l_leg() {
  return l_leg_.Add();
}
inline void equips::add_l_leg(const ::std::string& value) {
  l_leg_.Add()->assign(value);
}
inline void equips::add_l_leg(const char* value) {
  l_leg_.Add()->assign(value);
}
inline void equips::add_l_leg(const char* value, size_t size) {
  l_leg_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::l_leg() const {
  return l_leg_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_l_leg() {
  return &l_leg_;
}

// repeated string l_feet = 36;
inline int equips::l_feet_size() const {
  return l_feet_.size();
}
inline void equips::clear_l_feet() {
  l_feet_.Clear();
}
inline const ::std::string& equips::l_feet(int index) const {
  return l_feet_.Get(index);
}
inline ::std::string* equips::mutable_l_feet(int index) {
  return l_feet_.Mutable(index);
}
inline void equips::set_l_feet(int index, const ::std::string& value) {
  l_feet_.Mutable(index)->assign(value);
}
inline void equips::set_l_feet(int index, const char* value) {
  l_feet_.Mutable(index)->assign(value);
}
inline void equips::set_l_feet(int index, const char* value, size_t size) {
  l_feet_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_l_feet() {
  return l_feet_.Add();
}
inline void equips::add_l_feet(const ::std::string& value) {
  l_feet_.Add()->assign(value);
}
inline void equips::add_l_feet(const char* value) {
  l_feet_.Add()->assign(value);
}
inline void equips::add_l_feet(const char* value, size_t size) {
  l_feet_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::l_feet() const {
  return l_feet_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_l_feet() {
  return &l_feet_;
}

// repeated string a_head = 37;
inline int equips::a_head_size() const {
  return a_head_.size();
}
inline void equips::clear_a_head() {
  a_head_.Clear();
}
inline const ::std::string& equips::a_head(int index) const {
  return a_head_.Get(index);
}
inline ::std::string* equips::mutable_a_head(int index) {
  return a_head_.Mutable(index);
}
inline void equips::set_a_head(int index, const ::std::string& value) {
  a_head_.Mutable(index)->assign(value);
}
inline void equips::set_a_head(int index, const char* value) {
  a_head_.Mutable(index)->assign(value);
}
inline void equips::set_a_head(int index, const char* value, size_t size) {
  a_head_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_a_head() {
  return a_head_.Add();
}
inline void equips::add_a_head(const ::std::string& value) {
  a_head_.Add()->assign(value);
}
inline void equips::add_a_head(const char* value) {
  a_head_.Add()->assign(value);
}
inline void equips::add_a_head(const char* value, size_t size) {
  a_head_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::a_head() const {
  return a_head_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_a_head() {
  return &a_head_;
}

// repeated string a_chest = 38;
inline int equips::a_chest_size() const {
  return a_chest_.size();
}
inline void equips::clear_a_chest() {
  a_chest_.Clear();
}
inline const ::std::string& equips::a_chest(int index) const {
  return a_chest_.Get(index);
}
inline ::std::string* equips::mutable_a_chest(int index) {
  return a_chest_.Mutable(index);
}
inline void equips::set_a_chest(int index, const ::std::string& value) {
  a_chest_.Mutable(index)->assign(value);
}
inline void equips::set_a_chest(int index, const char* value) {
  a_chest_.Mutable(index)->assign(value);
}
inline void equips::set_a_chest(int index, const char* value, size_t size) {
  a_chest_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_a_chest() {
  return a_chest_.Add();
}
inline void equips::add_a_chest(const ::std::string& value) {
  a_chest_.Add()->assign(value);
}
inline void equips::add_a_chest(const char* value) {
  a_chest_.Add()->assign(value);
}
inline void equips::add_a_chest(const char* value, size_t size) {
  a_chest_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::a_chest() const {
  return a_chest_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_a_chest() {
  return &a_chest_;
}

// repeated string a_arm = 39;
inline int equips::a_arm_size() const {
  return a_arm_.size();
}
inline void equips::clear_a_arm() {
  a_arm_.Clear();
}
inline const ::std::string& equips::a_arm(int index) const {
  return a_arm_.Get(index);
}
inline ::std::string* equips::mutable_a_arm(int index) {
  return a_arm_.Mutable(index);
}
inline void equips::set_a_arm(int index, const ::std::string& value) {
  a_arm_.Mutable(index)->assign(value);
}
inline void equips::set_a_arm(int index, const char* value) {
  a_arm_.Mutable(index)->assign(value);
}
inline void equips::set_a_arm(int index, const char* value, size_t size) {
  a_arm_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_a_arm() {
  return a_arm_.Add();
}
inline void equips::add_a_arm(const ::std::string& value) {
  a_arm_.Add()->assign(value);
}
inline void equips::add_a_arm(const char* value) {
  a_arm_.Add()->assign(value);
}
inline void equips::add_a_arm(const char* value, size_t size) {
  a_arm_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::a_arm() const {
  return a_arm_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_a_arm() {
  return &a_arm_;
}

// repeated string a_hand = 40;
inline int equips::a_hand_size() const {
  return a_hand_.size();
}
inline void equips::clear_a_hand() {
  a_hand_.Clear();
}
inline const ::std::string& equips::a_hand(int index) const {
  return a_hand_.Get(index);
}
inline ::std::string* equips::mutable_a_hand(int index) {
  return a_hand_.Mutable(index);
}
inline void equips::set_a_hand(int index, const ::std::string& value) {
  a_hand_.Mutable(index)->assign(value);
}
inline void equips::set_a_hand(int index, const char* value) {
  a_hand_.Mutable(index)->assign(value);
}
inline void equips::set_a_hand(int index, const char* value, size_t size) {
  a_hand_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_a_hand() {
  return a_hand_.Add();
}
inline void equips::add_a_hand(const ::std::string& value) {
  a_hand_.Add()->assign(value);
}
inline void equips::add_a_hand(const char* value) {
  a_hand_.Add()->assign(value);
}
inline void equips::add_a_hand(const char* value, size_t size) {
  a_hand_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::a_hand() const {
  return a_hand_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_a_hand() {
  return &a_hand_;
}

// repeated string a_leg = 41;
inline int equips::a_leg_size() const {
  return a_leg_.size();
}
inline void equips::clear_a_leg() {
  a_leg_.Clear();
}
inline const ::std::string& equips::a_leg(int index) const {
  return a_leg_.Get(index);
}
inline ::std::string* equips::mutable_a_leg(int index) {
  return a_leg_.Mutable(index);
}
inline void equips::set_a_leg(int index, const ::std::string& value) {
  a_leg_.Mutable(index)->assign(value);
}
inline void equips::set_a_leg(int index, const char* value) {
  a_leg_.Mutable(index)->assign(value);
}
inline void equips::set_a_leg(int index, const char* value, size_t size) {
  a_leg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_a_leg() {
  return a_leg_.Add();
}
inline void equips::add_a_leg(const ::std::string& value) {
  a_leg_.Add()->assign(value);
}
inline void equips::add_a_leg(const char* value) {
  a_leg_.Add()->assign(value);
}
inline void equips::add_a_leg(const char* value, size_t size) {
  a_leg_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::a_leg() const {
  return a_leg_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_a_leg() {
  return &a_leg_;
}

// repeated string a_feet = 42;
inline int equips::a_feet_size() const {
  return a_feet_.size();
}
inline void equips::clear_a_feet() {
  a_feet_.Clear();
}
inline const ::std::string& equips::a_feet(int index) const {
  return a_feet_.Get(index);
}
inline ::std::string* equips::mutable_a_feet(int index) {
  return a_feet_.Mutable(index);
}
inline void equips::set_a_feet(int index, const ::std::string& value) {
  a_feet_.Mutable(index)->assign(value);
}
inline void equips::set_a_feet(int index, const char* value) {
  a_feet_.Mutable(index)->assign(value);
}
inline void equips::set_a_feet(int index, const char* value, size_t size) {
  a_feet_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equips::add_a_feet() {
  return a_feet_.Add();
}
inline void equips::add_a_feet(const ::std::string& value) {
  a_feet_.Add()->assign(value);
}
inline void equips::add_a_feet(const char* value) {
  a_feet_.Add()->assign(value);
}
inline void equips::add_a_feet(const char* value, size_t size) {
  a_feet_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
equips::a_feet() const {
  return a_feet_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
equips::mutable_a_feet() {
  return &a_feet_;
}

// -------------------------------------------------------------------

// dungeon_setup

// optional bool isactive = 43;
inline bool dungeon_setup::has_isactive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dungeon_setup::set_has_isactive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dungeon_setup::clear_has_isactive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dungeon_setup::clear_isactive() {
  isactive_ = false;
  clear_has_isactive();
}
inline bool dungeon_setup::isactive() const {
  return isactive_;
}
inline void dungeon_setup::set_isactive(bool value) {
  set_has_isactive();
  isactive_ = value;
}

// optional int32 room_count = 44;
inline bool dungeon_setup::has_room_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dungeon_setup::set_has_room_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dungeon_setup::clear_has_room_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dungeon_setup::clear_room_count() {
  room_count_ = 0;
  clear_has_room_count();
}
inline ::google::protobuf::int32 dungeon_setup::room_count() const {
  return room_count_;
}
inline void dungeon_setup::set_room_count(::google::protobuf::int32 value) {
  set_has_room_count();
  room_count_ = value;
}

// -------------------------------------------------------------------

// locations

// required bool first_time_abon = 45;
inline bool locations::has_first_time_abon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void locations::set_has_first_time_abon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void locations::clear_has_first_time_abon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void locations::clear_first_time_abon() {
  first_time_abon_ = false;
  clear_has_first_time_abon();
}
inline bool locations::first_time_abon() const {
  return first_time_abon_;
}
inline void locations::set_first_time_abon(bool value) {
  set_has_first_time_abon();
  first_time_abon_ = value;
}

// required bool first_time_mon = 46;
inline bool locations::has_first_time_mon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void locations::set_has_first_time_mon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void locations::clear_has_first_time_mon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void locations::clear_first_time_mon() {
  first_time_mon_ = false;
  clear_has_first_time_mon();
}
inline bool locations::first_time_mon() const {
  return first_time_mon_;
}
inline void locations::set_first_time_mon(bool value) {
  set_has_first_time_mon();
  first_time_mon_ = value;
}

// required bool first_time_farm = 47;
inline bool locations::has_first_time_farm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void locations::set_has_first_time_farm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void locations::clear_has_first_time_farm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void locations::clear_first_time_farm() {
  first_time_farm_ = false;
  clear_has_first_time_farm();
}
inline bool locations::first_time_farm() const {
  return first_time_farm_;
}
inline void locations::set_first_time_farm(bool value) {
  set_has_first_time_farm();
  first_time_farm_ = value;
}

// required bool first_time_boat = 48;
inline bool locations::has_first_time_boat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void locations::set_has_first_time_boat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void locations::clear_has_first_time_boat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void locations::clear_first_time_boat() {
  first_time_boat_ = false;
  clear_has_first_time_boat();
}
inline bool locations::first_time_boat() const {
  return first_time_boat_;
}
inline void locations::set_first_time_boat(bool value) {
  set_has_first_time_boat();
  first_time_boat_ = value;
}

// optional string rand_house_item = 49;
inline bool locations::has_rand_house_item() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void locations::set_has_rand_house_item() {
  _has_bits_[0] |= 0x00000010u;
}
inline void locations::clear_has_rand_house_item() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void locations::clear_rand_house_item() {
  if (rand_house_item_ != &::google::protobuf::internal::kEmptyString) {
    rand_house_item_->clear();
  }
  clear_has_rand_house_item();
}
inline const ::std::string& locations::rand_house_item() const {
  return *rand_house_item_;
}
inline void locations::set_rand_house_item(const ::std::string& value) {
  set_has_rand_house_item();
  if (rand_house_item_ == &::google::protobuf::internal::kEmptyString) {
    rand_house_item_ = new ::std::string;
  }
  rand_house_item_->assign(value);
}
inline void locations::set_rand_house_item(const char* value) {
  set_has_rand_house_item();
  if (rand_house_item_ == &::google::protobuf::internal::kEmptyString) {
    rand_house_item_ = new ::std::string;
  }
  rand_house_item_->assign(value);
}
inline void locations::set_rand_house_item(const char* value, size_t size) {
  set_has_rand_house_item();
  if (rand_house_item_ == &::google::protobuf::internal::kEmptyString) {
    rand_house_item_ = new ::std::string;
  }
  rand_house_item_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* locations::mutable_rand_house_item() {
  set_has_rand_house_item();
  if (rand_house_item_ == &::google::protobuf::internal::kEmptyString) {
    rand_house_item_ = new ::std::string;
  }
  return rand_house_item_;
}
inline ::std::string* locations::release_rand_house_item() {
  clear_has_rand_house_item();
  if (rand_house_item_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rand_house_item_;
    rand_house_item_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void locations::set_allocated_rand_house_item(::std::string* rand_house_item) {
  if (rand_house_item_ != &::google::protobuf::internal::kEmptyString) {
    delete rand_house_item_;
  }
  if (rand_house_item) {
    set_has_rand_house_item();
    rand_house_item_ = rand_house_item;
  } else {
    clear_has_rand_house_item();
    rand_house_item_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dot_count = 50;
inline bool locations::has_dot_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void locations::set_has_dot_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void locations::clear_has_dot_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void locations::clear_dot_count() {
  dot_count_ = 0;
  clear_has_dot_count();
}
inline ::google::protobuf::int32 locations::dot_count() const {
  return dot_count_;
}
inline void locations::set_dot_count(::google::protobuf::int32 value) {
  set_has_dot_count();
  dot_count_ = value;
}

// optional int32 dot_stop = 51;
inline bool locations::has_dot_stop() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void locations::set_has_dot_stop() {
  _has_bits_[0] |= 0x00000040u;
}
inline void locations::clear_has_dot_stop() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void locations::clear_dot_stop() {
  dot_stop_ = 0;
  clear_has_dot_stop();
}
inline ::google::protobuf::int32 locations::dot_stop() const {
  return dot_stop_;
}
inline void locations::set_dot_stop(::google::protobuf::int32 value) {
  set_has_dot_stop();
  dot_stop_ = value;
}

// -------------------------------------------------------------------

// story

// required int32 progress = 52;
inline bool story::has_progress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void story::set_has_progress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void story::clear_has_progress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void story::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline ::google::protobuf::int32 story::progress() const {
  return progress_;
}
inline void story::set_progress(::google::protobuf::int32 value) {
  set_has_progress();
  progress_ = value;
}

// required string back_story = 53;
inline bool story::has_back_story() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void story::set_has_back_story() {
  _has_bits_[0] |= 0x00000002u;
}
inline void story::clear_has_back_story() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void story::clear_back_story() {
  if (back_story_ != &::google::protobuf::internal::kEmptyString) {
    back_story_->clear();
  }
  clear_has_back_story();
}
inline const ::std::string& story::back_story() const {
  return *back_story_;
}
inline void story::set_back_story(const ::std::string& value) {
  set_has_back_story();
  if (back_story_ == &::google::protobuf::internal::kEmptyString) {
    back_story_ = new ::std::string;
  }
  back_story_->assign(value);
}
inline void story::set_back_story(const char* value) {
  set_has_back_story();
  if (back_story_ == &::google::protobuf::internal::kEmptyString) {
    back_story_ = new ::std::string;
  }
  back_story_->assign(value);
}
inline void story::set_back_story(const char* value, size_t size) {
  set_has_back_story();
  if (back_story_ == &::google::protobuf::internal::kEmptyString) {
    back_story_ = new ::std::string;
  }
  back_story_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_back_story() {
  set_has_back_story();
  if (back_story_ == &::google::protobuf::internal::kEmptyString) {
    back_story_ = new ::std::string;
  }
  return back_story_;
}
inline ::std::string* story::release_back_story() {
  clear_has_back_story();
  if (back_story_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = back_story_;
    back_story_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_back_story(::std::string* back_story) {
  if (back_story_ != &::google::protobuf::internal::kEmptyString) {
    delete back_story_;
  }
  if (back_story) {
    set_has_back_story();
    back_story_ = back_story;
  } else {
    clear_has_back_story();
    back_story_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event1 = 54;
inline bool story::has_event1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void story::set_has_event1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void story::clear_has_event1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void story::clear_event1() {
  if (event1_ != &::google::protobuf::internal::kEmptyString) {
    event1_->clear();
  }
  clear_has_event1();
}
inline const ::std::string& story::event1() const {
  return *event1_;
}
inline void story::set_event1(const ::std::string& value) {
  set_has_event1();
  if (event1_ == &::google::protobuf::internal::kEmptyString) {
    event1_ = new ::std::string;
  }
  event1_->assign(value);
}
inline void story::set_event1(const char* value) {
  set_has_event1();
  if (event1_ == &::google::protobuf::internal::kEmptyString) {
    event1_ = new ::std::string;
  }
  event1_->assign(value);
}
inline void story::set_event1(const char* value, size_t size) {
  set_has_event1();
  if (event1_ == &::google::protobuf::internal::kEmptyString) {
    event1_ = new ::std::string;
  }
  event1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_event1() {
  set_has_event1();
  if (event1_ == &::google::protobuf::internal::kEmptyString) {
    event1_ = new ::std::string;
  }
  return event1_;
}
inline ::std::string* story::release_event1() {
  clear_has_event1();
  if (event1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event1_;
    event1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_event1(::std::string* event1) {
  if (event1_ != &::google::protobuf::internal::kEmptyString) {
    delete event1_;
  }
  if (event1) {
    set_has_event1();
    event1_ = event1;
  } else {
    clear_has_event1();
    event1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event2 = 55;
inline bool story::has_event2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void story::set_has_event2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void story::clear_has_event2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void story::clear_event2() {
  if (event2_ != &::google::protobuf::internal::kEmptyString) {
    event2_->clear();
  }
  clear_has_event2();
}
inline const ::std::string& story::event2() const {
  return *event2_;
}
inline void story::set_event2(const ::std::string& value) {
  set_has_event2();
  if (event2_ == &::google::protobuf::internal::kEmptyString) {
    event2_ = new ::std::string;
  }
  event2_->assign(value);
}
inline void story::set_event2(const char* value) {
  set_has_event2();
  if (event2_ == &::google::protobuf::internal::kEmptyString) {
    event2_ = new ::std::string;
  }
  event2_->assign(value);
}
inline void story::set_event2(const char* value, size_t size) {
  set_has_event2();
  if (event2_ == &::google::protobuf::internal::kEmptyString) {
    event2_ = new ::std::string;
  }
  event2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_event2() {
  set_has_event2();
  if (event2_ == &::google::protobuf::internal::kEmptyString) {
    event2_ = new ::std::string;
  }
  return event2_;
}
inline ::std::string* story::release_event2() {
  clear_has_event2();
  if (event2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event2_;
    event2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_event2(::std::string* event2) {
  if (event2_ != &::google::protobuf::internal::kEmptyString) {
    delete event2_;
  }
  if (event2) {
    set_has_event2();
    event2_ = event2;
  } else {
    clear_has_event2();
    event2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event3 = 56;
inline bool story::has_event3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void story::set_has_event3() {
  _has_bits_[0] |= 0x00000010u;
}
inline void story::clear_has_event3() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void story::clear_event3() {
  if (event3_ != &::google::protobuf::internal::kEmptyString) {
    event3_->clear();
  }
  clear_has_event3();
}
inline const ::std::string& story::event3() const {
  return *event3_;
}
inline void story::set_event3(const ::std::string& value) {
  set_has_event3();
  if (event3_ == &::google::protobuf::internal::kEmptyString) {
    event3_ = new ::std::string;
  }
  event3_->assign(value);
}
inline void story::set_event3(const char* value) {
  set_has_event3();
  if (event3_ == &::google::protobuf::internal::kEmptyString) {
    event3_ = new ::std::string;
  }
  event3_->assign(value);
}
inline void story::set_event3(const char* value, size_t size) {
  set_has_event3();
  if (event3_ == &::google::protobuf::internal::kEmptyString) {
    event3_ = new ::std::string;
  }
  event3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_event3() {
  set_has_event3();
  if (event3_ == &::google::protobuf::internal::kEmptyString) {
    event3_ = new ::std::string;
  }
  return event3_;
}
inline ::std::string* story::release_event3() {
  clear_has_event3();
  if (event3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event3_;
    event3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_event3(::std::string* event3) {
  if (event3_ != &::google::protobuf::internal::kEmptyString) {
    delete event3_;
  }
  if (event3) {
    set_has_event3();
    event3_ = event3;
  } else {
    clear_has_event3();
    event3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event4 = 57;
inline bool story::has_event4() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void story::set_has_event4() {
  _has_bits_[0] |= 0x00000020u;
}
inline void story::clear_has_event4() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void story::clear_event4() {
  if (event4_ != &::google::protobuf::internal::kEmptyString) {
    event4_->clear();
  }
  clear_has_event4();
}
inline const ::std::string& story::event4() const {
  return *event4_;
}
inline void story::set_event4(const ::std::string& value) {
  set_has_event4();
  if (event4_ == &::google::protobuf::internal::kEmptyString) {
    event4_ = new ::std::string;
  }
  event4_->assign(value);
}
inline void story::set_event4(const char* value) {
  set_has_event4();
  if (event4_ == &::google::protobuf::internal::kEmptyString) {
    event4_ = new ::std::string;
  }
  event4_->assign(value);
}
inline void story::set_event4(const char* value, size_t size) {
  set_has_event4();
  if (event4_ == &::google::protobuf::internal::kEmptyString) {
    event4_ = new ::std::string;
  }
  event4_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_event4() {
  set_has_event4();
  if (event4_ == &::google::protobuf::internal::kEmptyString) {
    event4_ = new ::std::string;
  }
  return event4_;
}
inline ::std::string* story::release_event4() {
  clear_has_event4();
  if (event4_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event4_;
    event4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_event4(::std::string* event4) {
  if (event4_ != &::google::protobuf::internal::kEmptyString) {
    delete event4_;
  }
  if (event4) {
    set_has_event4();
    event4_ = event4;
  } else {
    clear_has_event4();
    event4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event5 = 58;
inline bool story::has_event5() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void story::set_has_event5() {
  _has_bits_[0] |= 0x00000040u;
}
inline void story::clear_has_event5() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void story::clear_event5() {
  if (event5_ != &::google::protobuf::internal::kEmptyString) {
    event5_->clear();
  }
  clear_has_event5();
}
inline const ::std::string& story::event5() const {
  return *event5_;
}
inline void story::set_event5(const ::std::string& value) {
  set_has_event5();
  if (event5_ == &::google::protobuf::internal::kEmptyString) {
    event5_ = new ::std::string;
  }
  event5_->assign(value);
}
inline void story::set_event5(const char* value) {
  set_has_event5();
  if (event5_ == &::google::protobuf::internal::kEmptyString) {
    event5_ = new ::std::string;
  }
  event5_->assign(value);
}
inline void story::set_event5(const char* value, size_t size) {
  set_has_event5();
  if (event5_ == &::google::protobuf::internal::kEmptyString) {
    event5_ = new ::std::string;
  }
  event5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_event5() {
  set_has_event5();
  if (event5_ == &::google::protobuf::internal::kEmptyString) {
    event5_ = new ::std::string;
  }
  return event5_;
}
inline ::std::string* story::release_event5() {
  clear_has_event5();
  if (event5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event5_;
    event5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_event5(::std::string* event5) {
  if (event5_ != &::google::protobuf::internal::kEmptyString) {
    delete event5_;
  }
  if (event5) {
    set_has_event5();
    event5_ = event5;
  } else {
    clear_has_event5();
    event5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event6 = 59;
inline bool story::has_event6() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void story::set_has_event6() {
  _has_bits_[0] |= 0x00000080u;
}
inline void story::clear_has_event6() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void story::clear_event6() {
  if (event6_ != &::google::protobuf::internal::kEmptyString) {
    event6_->clear();
  }
  clear_has_event6();
}
inline const ::std::string& story::event6() const {
  return *event6_;
}
inline void story::set_event6(const ::std::string& value) {
  set_has_event6();
  if (event6_ == &::google::protobuf::internal::kEmptyString) {
    event6_ = new ::std::string;
  }
  event6_->assign(value);
}
inline void story::set_event6(const char* value) {
  set_has_event6();
  if (event6_ == &::google::protobuf::internal::kEmptyString) {
    event6_ = new ::std::string;
  }
  event6_->assign(value);
}
inline void story::set_event6(const char* value, size_t size) {
  set_has_event6();
  if (event6_ == &::google::protobuf::internal::kEmptyString) {
    event6_ = new ::std::string;
  }
  event6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_event6() {
  set_has_event6();
  if (event6_ == &::google::protobuf::internal::kEmptyString) {
    event6_ = new ::std::string;
  }
  return event6_;
}
inline ::std::string* story::release_event6() {
  clear_has_event6();
  if (event6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event6_;
    event6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_event6(::std::string* event6) {
  if (event6_ != &::google::protobuf::internal::kEmptyString) {
    delete event6_;
  }
  if (event6) {
    set_has_event6();
    event6_ = event6;
  } else {
    clear_has_event6();
    event6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event7 = 60;
inline bool story::has_event7() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void story::set_has_event7() {
  _has_bits_[0] |= 0x00000100u;
}
inline void story::clear_has_event7() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void story::clear_event7() {
  if (event7_ != &::google::protobuf::internal::kEmptyString) {
    event7_->clear();
  }
  clear_has_event7();
}
inline const ::std::string& story::event7() const {
  return *event7_;
}
inline void story::set_event7(const ::std::string& value) {
  set_has_event7();
  if (event7_ == &::google::protobuf::internal::kEmptyString) {
    event7_ = new ::std::string;
  }
  event7_->assign(value);
}
inline void story::set_event7(const char* value) {
  set_has_event7();
  if (event7_ == &::google::protobuf::internal::kEmptyString) {
    event7_ = new ::std::string;
  }
  event7_->assign(value);
}
inline void story::set_event7(const char* value, size_t size) {
  set_has_event7();
  if (event7_ == &::google::protobuf::internal::kEmptyString) {
    event7_ = new ::std::string;
  }
  event7_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_event7() {
  set_has_event7();
  if (event7_ == &::google::protobuf::internal::kEmptyString) {
    event7_ = new ::std::string;
  }
  return event7_;
}
inline ::std::string* story::release_event7() {
  clear_has_event7();
  if (event7_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event7_;
    event7_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_event7(::std::string* event7) {
  if (event7_ != &::google::protobuf::internal::kEmptyString) {
    delete event7_;
  }
  if (event7) {
    set_has_event7();
    event7_ = event7;
  } else {
    clear_has_event7();
    event7_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event8 = 61;
inline bool story::has_event8() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void story::set_has_event8() {
  _has_bits_[0] |= 0x00000200u;
}
inline void story::clear_has_event8() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void story::clear_event8() {
  if (event8_ != &::google::protobuf::internal::kEmptyString) {
    event8_->clear();
  }
  clear_has_event8();
}
inline const ::std::string& story::event8() const {
  return *event8_;
}
inline void story::set_event8(const ::std::string& value) {
  set_has_event8();
  if (event8_ == &::google::protobuf::internal::kEmptyString) {
    event8_ = new ::std::string;
  }
  event8_->assign(value);
}
inline void story::set_event8(const char* value) {
  set_has_event8();
  if (event8_ == &::google::protobuf::internal::kEmptyString) {
    event8_ = new ::std::string;
  }
  event8_->assign(value);
}
inline void story::set_event8(const char* value, size_t size) {
  set_has_event8();
  if (event8_ == &::google::protobuf::internal::kEmptyString) {
    event8_ = new ::std::string;
  }
  event8_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_event8() {
  set_has_event8();
  if (event8_ == &::google::protobuf::internal::kEmptyString) {
    event8_ = new ::std::string;
  }
  return event8_;
}
inline ::std::string* story::release_event8() {
  clear_has_event8();
  if (event8_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event8_;
    event8_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_event8(::std::string* event8) {
  if (event8_ != &::google::protobuf::internal::kEmptyString) {
    delete event8_;
  }
  if (event8) {
    set_has_event8();
    event8_ = event8;
  } else {
    clear_has_event8();
    event8_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event9 = 62;
inline bool story::has_event9() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void story::set_has_event9() {
  _has_bits_[0] |= 0x00000400u;
}
inline void story::clear_has_event9() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void story::clear_event9() {
  if (event9_ != &::google::protobuf::internal::kEmptyString) {
    event9_->clear();
  }
  clear_has_event9();
}
inline const ::std::string& story::event9() const {
  return *event9_;
}
inline void story::set_event9(const ::std::string& value) {
  set_has_event9();
  if (event9_ == &::google::protobuf::internal::kEmptyString) {
    event9_ = new ::std::string;
  }
  event9_->assign(value);
}
inline void story::set_event9(const char* value) {
  set_has_event9();
  if (event9_ == &::google::protobuf::internal::kEmptyString) {
    event9_ = new ::std::string;
  }
  event9_->assign(value);
}
inline void story::set_event9(const char* value, size_t size) {
  set_has_event9();
  if (event9_ == &::google::protobuf::internal::kEmptyString) {
    event9_ = new ::std::string;
  }
  event9_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_event9() {
  set_has_event9();
  if (event9_ == &::google::protobuf::internal::kEmptyString) {
    event9_ = new ::std::string;
  }
  return event9_;
}
inline ::std::string* story::release_event9() {
  clear_has_event9();
  if (event9_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event9_;
    event9_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_event9(::std::string* event9) {
  if (event9_ != &::google::protobuf::internal::kEmptyString) {
    delete event9_;
  }
  if (event9) {
    set_has_event9();
    event9_ = event9;
  } else {
    clear_has_event9();
    event9_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string event10 = 63;
inline bool story::has_event10() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void story::set_has_event10() {
  _has_bits_[0] |= 0x00000800u;
}
inline void story::clear_has_event10() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void story::clear_event10() {
  if (event10_ != &::google::protobuf::internal::kEmptyString) {
    event10_->clear();
  }
  clear_has_event10();
}
inline const ::std::string& story::event10() const {
  return *event10_;
}
inline void story::set_event10(const ::std::string& value) {
  set_has_event10();
  if (event10_ == &::google::protobuf::internal::kEmptyString) {
    event10_ = new ::std::string;
  }
  event10_->assign(value);
}
inline void story::set_event10(const char* value) {
  set_has_event10();
  if (event10_ == &::google::protobuf::internal::kEmptyString) {
    event10_ = new ::std::string;
  }
  event10_->assign(value);
}
inline void story::set_event10(const char* value, size_t size) {
  set_has_event10();
  if (event10_ == &::google::protobuf::internal::kEmptyString) {
    event10_ = new ::std::string;
  }
  event10_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* story::mutable_event10() {
  set_has_event10();
  if (event10_ == &::google::protobuf::internal::kEmptyString) {
    event10_ = new ::std::string;
  }
  return event10_;
}
inline ::std::string* story::release_event10() {
  clear_has_event10();
  if (event10_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event10_;
    event10_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void story::set_allocated_event10(::std::string* event10) {
  if (event10_ != &::google::protobuf::internal::kEmptyString) {
    delete event10_;
  }
  if (event10) {
    set_has_event10();
    event10_ = event10;
  } else {
    clear_has_event10();
    event10_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace RPG

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RPG_2eproto__INCLUDED
